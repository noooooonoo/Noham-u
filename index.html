
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG 3D - Terres d'Aventure</title>
    <style>
        .touch-btn {
            width: 48px;
            height: 48px;
            background: rgba(50,50,50,0.8);
            color: #FFD700;
            font-size: 30px;
            border: 2px solid #FFD700;
            border-radius: 16px;
            margin: 3px;
            cursor: pointer;
            touch-action: manipulation;
        }
        .touch-btn:active {
            background: #FFD700;
            color: #333;
        }
        .cinematic {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, rgba(10,10,30,0.97), rgba(40,20,60,0.97));
            color: #FFD700;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            z-index: 100;
            text-align: center;
            padding: 20px;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: white;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            user-select: none;
        }

        .health-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 250px;
            height: 30px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #FFD700;
            border-radius: 15px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6b6b);
            transition: width 0.3s;
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
        }

        .hunger-bar {
            position: absolute;
            top: 60px;
            left: 20px;
            width: 250px;
            height: 30px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #8B4513;
            border-radius: 15px;
            overflow: hidden;
        }

        .hunger-fill {
            height: 100%;
            background: linear-gradient(90deg, #8B4513, #D2691E);
            transition: width 0.3s;
            box-shadow: 0 0 20px rgba(139,69,19,0.5);
        }

        .experience-bar {
            position: absolute;
            top: 100px;
            left: 20px;
            width: 250px;
            height: 30px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #FFD700;
            border-radius: 15px;
            overflow: hidden;
        }

        .experience-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            transition: width 0.3s;
            box-shadow: 0 0 20px rgba(255,215,0,0.5);
        }

        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #FFD700;
            font-size: 14px;
        }

        .inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #FFD700;
            pointer-events: all;
        }

        .inventory-slot {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.1);
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .inventory-slot:hover {
            background: rgba(255,255,255,0.2);
            border-color: #FFD700;
            transform: scale(1.1);
        }

        .inventory-slot.selected {
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0,255,0,0.5);
        }

        .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: #FFD700;
            color: #000;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        }

        .quest-log {
            position: absolute;
            top: 150px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #9370DB;
            max-width: 300px;
        }

        .quest-title {
            color: #FFD700;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .controls {
            position: absolute;
            bottom: 100px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4169E1;
            font-size: 12px;
        }

        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 20px 40px;
            border-radius: 10px;
            border: 2px solid #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            display: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        .minimap {
            position: absolute;
            top: 20px;
            right: 320px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #00CED1;
            border-radius: 10px;
            overflow: hidden;
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
        }

        .dialog-box {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(30,30,30,0.95));
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #FFD700;
            max-width: 600px;
            display: none;
            pointer-events: all;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        .dialog-speaker {
            color: #FFD700;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .dialog-text {
            font-size: 16px;
            line-height: 1.5;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            color: #FFD700;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Chargement du monde...</div>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div class="health-bar">
            <div class="health-fill" id="healthFill" style="width: 100%"></div>
        </div>
        <div class="hunger-bar">
            <div class="hunger-fill" id="hungerFill" style="width: 100%"></div>
        </div>
        <div class="experience-bar">
            <div class="experience-fill" id="experienceFill" style="width: 0%"></div>
        </div>

        <div class="stats">
            <div>Niveau: <span id="level">1</span></div>
            <div>Or: <span id="gold">0</span></div>
            <div>Position: <span id="position">0, 0</span></div>
            <div>Temps: <span id="gameTime">Jour</span></div>
        </div>

        <div class="quest-log">
            <div class="quest-title">Qu√™te Active:</div>
            <div id="questText">Trouve l'√©p√©e dans la maison de d√©part</div>
        </div>

        <div class="controls">
            <div><strong>Contr√¥les:</strong></div>
            <div>ZQSD/WASD - Se d√©placer</div>
            <div>Fl√®ches ‚Üê‚Üí‚Üë‚Üì - Cam√©ra</div>
            <div>Clic gauche - Attaquer/Interagir</div>
            <div>Espace - Sauter</div>
            <div>E - Ramasser/Parler/Entrer</div>
            <div>1-5 - S√©lectionner objet</div>
            <div>Q - Accepter qu√™te</div>
            <div>C - Commerce</div>
            <div>F - Crafting</div>
        </div>

        <div class="minimap">
            <canvas id="minimapCanvas"></canvas>
        </div>

        <div class="inventory">
            <div class="inventory-slot selected" data-slot="0">‚ùå</div>
            <div class="inventory-slot" data-slot="1">üçñ<span class="item-count">5</span></div>
            <div class="inventory-slot" data-slot="2">üß™<span class="item-count">3</span></div>
            <div class="inventory-slot" data-slot="3">ü™ô<span class="item-count">10</span></div>
            <div class="inventory-slot" data-slot="4">üìú</div>
        </div>

        <div class="dialog-box" id="dialogBox">
            <div class="dialog-speaker" id="dialogSpeaker">Villageois</div>
            <div class="dialog-text" id="dialogText"></div>
        </div>

        <div class="message" id="message"></div>
    </div>

    <div class="cinematic" id="cinematic">
        <div style="font-size: 2.5rem; margin-bottom: 30px;">üè∞ Les Terres d'Aventure üè∞</div>
        <div style="margin: 20px 0;">Il √©tait une fois‚Ä¶</div>
        <div style="margin: 20px 0;">Un monde envahi par les monstres‚Ä¶</div>
        <div style="margin: 20px 0;">R√©veill√© dans une maison √©trange, tu dois trouver ton √©p√©e et sauver le village !</div>
        <button class="touch-btn" style="margin-top:40px; width: auto; padding: 15px 30px;" onclick="endCinematic()">‚öîÔ∏è Commencer l'Aventure</button>
    </div>

    <div id="touchControls" style="display:none; position:absolute;bottom:20px;left:0;right:0;z-index:10;pointer-events:none;">
        <!-- Joystick virtuel gauche pour d√©placement -->
        <div id="joystickLeft" style="position:absolute;bottom:20px;left:20px;width:120px;height:120px;background:rgba(50,50,50,0.5);border:3px solid #FFD700;border-radius:50%;pointer-events:all;">
            <div id="joystickKnobLeft" style="position:absolute;width:50px;height:50px;background:#FFD700;border-radius:50%;top:50%;left:50%;transform:translate(-50%,-50%);"></div>
        </div>

        <!-- Joystick virtuel droite pour cam√©ra -->
        <div id="joystickRight" style="position:absolute;bottom:20px;right:20px;width:120px;height:120px;background:rgba(50,50,50,0.5);border:3px solid #FFD700;border-radius:50%;pointer-events:all;">
            <div id="joystickKnobRight" style="position:absolute;width:50px;height:50px;background:#FFD700;border-radius:50%;top:50%;left:50%;transform:translate(-50%,-50%);"></div>
        </div>

        <!-- Boutons d'action -->
        <div style="position:absolute;bottom:160px;right:20px;display:flex;flex-direction:column;gap:10px;pointer-events:all;">
            <button class="touch-btn" id="btnJump" style="width:60px;height:60px;font-size:24px;">‚è´</button>
            <button class="touch-btn" id="btnAction" style="width:60px;height:60px;font-size:24px;">‚öîÔ∏è</button>
            <button class="touch-btn" id="btnInteract" style="width:60px;height:60px;font-size:24px;">üó®Ô∏è</button>
            <button class="touch-btn" id="btnEnter" style="width:60px;height:60px;font-size:24px;background:rgba(100,50,200,0.8);border-color:#9370DB;display:none;">üö™</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variables globales du jeu
        let scene, camera, renderer;
        let player, playerMesh;
        let world = {};
        let enemies = [];
        let npcs = [];
        let items = [];
        let particles = [];
        let buildings = [];
        let trees = [];
        let chests = [];
        let animals = [];
        let indoorMode = false;
        let currentBuilding = null;
        let composer, bloomPass;
        let particleSystem = null;

        // Syst√®me de chunks
        const CHUNK_SIZE = 50;
        const RENDER_DISTANCE = 3; // Nombre de chunks √† rendre autour du joueur
        let chunks = new Map();
        let activeChunks = new Set();
        let lastPlayerChunk = { x: 0, z: 0 };

        // √âtat du joueur
        let playerStats = {
            health: 100,
            maxHealth: 100,
            hunger: 100,
            maxHunger: 100,
            experience: 0,
            level: 1,
            gold: 0,
            damage: 10,
            defense: 5,
            speed: 0.22,
            jumpPower: 0.35,
            hasSword: false
        };

        // Inventaire
        let inventory = [
            { type: 'empty', name: 'Vide', icon: '‚ùå', quantity: 0 },
            { type: 'food', name: 'Viande', icon: 'üçñ', heal: 20, hunger: 30, quantity: 5 },
            { type: 'potion', name: 'Potion', icon: 'üß™', heal: 50, quantity: 3 },
            { type: 'gold', name: 'Pi√®ces', icon: 'ü™ô', quantity: 10 },
            { type: 'quest', name: 'Parchemin', icon: 'üìú', quantity: 1 }
        ];
        let selectedSlot = 0;

        // Contr√¥les
        let keys = {};
        let touchKeys = {};
        let mouseX = 0, mouseY = 0;
        let isPointerLocked = false;
        let velocity = new THREE.Vector3();
        let canJump = true;

        // Joysticks virtuels
        let joystickLeftActive = false;
        let joystickRightActive = false;
        let joystickLeftVector = { x: 0, y: 0 };
        let joystickRightVector = { x: 0, y: 0 };

        // Animation du personnage
        let walkAnimationTime = 0;
        let isPlayerMoving = false;

        // Temps de jeu
        let gameTime = 0;
        let dayNightCycle = true;

        // √ânigmes et qu√™tes
        let dungeonPuzzleSolved = false;
        let startHousePosition = { x: 0, y: 0, z: 0 };

        // Syst√®me de qu√™tes avanc√©
        let questSystem = {
            activeQuests: [],
            completedQuests: [],
            availableQuests: [
                {
                    id: 'sword_quest',
                    name: 'Premi√®re Arme',
                    description: 'Trouve l\'√©p√©e dans la maison de d√©part',
                    type: 'collecte',
                    objectives: [{ type: 'item', target: 'sword', current: 0, required: 1 }],
                    rewards: { exp: 50, gold: 20 },
                    completed: false
                },
                {
                    id: 'explorer_quest',
                    name: 'Explorateur D√©butant',
                    description: 'Explore les 4 biomes diff√©rents',
                    type: 'exploration',
                    objectives: [
                        { type: 'biome', target: 'desert', visited: false },
                        { type: 'biome', target: 'snow', visited: false },
                        { type: 'biome', target: 'swamp', visited: false },
                        { type: 'biome', target: 'mountain', visited: false }
                    ],
                    rewards: { exp: 100, gold: 50 },
                    completed: false
                },
                {
                    id: 'slayer_quest',
                    name: 'Chasseur de Slimes',
                    description: '√âlimine 5 slimes',
                    type: 'combat',
                    objectives: [{ type: 'kill', target: 'slime', current: 0, required: 5 }],
                    rewards: { exp: 80, gold: 40 },
                    completed: false
                },
                {
                    id: 'collector_quest',
                    name: 'Chercheur de Tr√©sors',
                    description: 'Ouvre 3 coffres',
                    type: 'collecte',
                    objectives: [{ type: 'chest', current: 0, required: 3 }],
                    rewards: { exp: 60, gold: 30 },
                    completed: false
                },
                {
                    id: 'dungeon_master',
                    name: 'Ma√Ætre du Donjon',
                    description: 'Compl√®te un donjon et bat le boss',
                    type: 'combat',
                    objectives: [{ type: 'kill', target: 'boss', current: 0, required: 1 }],
                    rewards: { exp: 200, gold: 150 },
                    completed: false
                },
                {
                    id: 'gatherer_quest',
                    name: 'Chasseur de Richesses',
                    description: 'Collecte 100 pi√®ces d\'or',
                    type: 'collecte',
                    objectives: [{ type: 'gold', current: 0, required: 100 }],
                    rewards: { exp: 150, gold: 50 },
                    completed: false
                }
            ]
        };

        function startQuest(questId) {
            const quest = questSystem.availableQuests.find(q => q.id === questId);
            if (quest && !quest.completed && !questSystem.activeQuests.find(q => q.id === questId)) {
                questSystem.activeQuests.push(quest);
                updateQuestUI();
                showMessage(`Qu√™te accept√©e: ${quest.name}`);
            }
        }

        function updateQuestProgress(type, target, amount = 1) {
            questSystem.activeQuests.forEach(quest => {
                quest.objectives.forEach(obj => {
                    if (obj.type === type && (!obj.target || obj.target === target)) {
                        if (obj.current !== undefined) {
                            obj.current = Math.min(obj.current + amount, obj.required);
                        } else if (obj.visited !== undefined && target) {
                            obj.visited = true;
                        }
                        checkQuestCompletion(quest);
                    }
                });
            });
            updateQuestUI();
        }

        function checkQuestCompletion(quest) {
            let allComplete = true;
            quest.objectives.forEach(obj => {
                if (obj.current !== undefined && obj.current < obj.required) {
                    allComplete = false;
                } else if (obj.visited !== undefined && !obj.visited) {
                    allComplete = false;
                }
            });

            if (allComplete && !quest.completed) {
                quest.completed = true;
                questSystem.completedQuests.push(quest);
                questSystem.activeQuests = questSystem.activeQuests.filter(q => q.id !== quest.id);
                
                // R√©compenses
                playerStats.experience += quest.rewards.exp;
                playerStats.gold += quest.rewards.gold;
                
                // Niveau up
                const expNeeded = playerStats.level * 100;
                if (playerStats.experience >= expNeeded) {
                    playerStats.level++;
                    playerStats.experience -= expNeeded;
                    playerStats.maxHealth += 20;
                    playerStats.health = playerStats.maxHealth;
                    playerStats.damage += 5;
                    showMessage(`üéâ Niveau ${playerStats.level} atteint !`);
                }
                
                showMessage(`‚úÖ Qu√™te termin√©e: ${quest.name}! +${quest.rewards.exp} EXP, +${quest.rewards.gold} Or`);
                updateQuestUI();
            }
        }

        function updateQuestUI() {
            const questText = document.getElementById('questText');
            if (questSystem.activeQuests.length > 0) {
                const quest = questSystem.activeQuests[0];
                let text = `${quest.name}\n`;
                quest.objectives.forEach(obj => {
                    if (obj.current !== undefined) {
                        text += `- ${obj.current}/${obj.required}\n`;
                    } else if (obj.visited !== undefined) {
                        text += `- ${obj.target}: ${obj.visited ? '‚úì' : '‚úó'}\n`;
                    }
                });
                questText.innerHTML = text.replace(/\n/g, '<br>');
            } else {
                questText.textContent = 'Parlez √† un PNJ pour obtenir une qu√™te';
            }
        }

        function endCinematic() {
            document.getElementById('cinematic').style.display = 'none';
        }

        // Initialisation du jeu
        function init() {
            // Sc√®ne
            scene = new THREE.Scene();

            // Cam√©ra
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 10);

            // Renderer optimis√© pour de meilleurs graphismes
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('gameCanvas'), 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3;

            // Lumi√®res ultra-am√©lior√©es pour de meilleurs graphismes
            const ambientLight = new THREE.AmbientLight(0x6495ED, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xFFF5E1, 1.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -200;
            directionalLight.shadow.camera.right = 200;
            directionalLight.shadow.camera.top = 200;
            directionalLight.shadow.camera.bottom = -200;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.bias = -0.0005;
            directionalLight.shadow.radius = 4;
            scene.add(directionalLight);

            // Lumi√®re d'appoint pour un meilleur rendu
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x8B4513, 0.7);
            scene.add(hemisphereLight);
            
            // Lumi√®re de remplissage pour r√©duire les ombres trop dures
            const fillLight = new THREE.DirectionalLight(0xFFFFFF, 0.3);
            fillLight.position.set(-50, 50, -50);
            scene.add(fillLight);

            // Fog atmosph√©rique
            scene.fog = new THREE.Fog(0x87CEEB, 50, 400);

            // Cr√©er le monde
            createWorld();
            createPlayer();

            // Cr√©er la maison de d√©part avec l'√©p√©e
            startHousePosition = createStartHouse(0, 0, 0);

            // Placer le joueur dans la maison de d√©part au bon niveau du sol
            player.position.set(startHousePosition.x, 0.5, startHousePosition.z);

            createVillage(50, 0, 50);
            createNPC(55, 0, 55, 'Ma√Ætre des Qu√™tes', 0xFFD700, 'quest_giver');
            createDungeon(-100, 0, -100);
            createDungeon(150, 0, 150);
            createDungeon(-150, 0, 150);
            createDungeon(100, 0, -150);
            createForest();
            spawnEnemies();
            spawnChests();
            spawnAnimals();

            // Nouveau contenu
            createMerchantShop(70, 0, 70);
            createBlacksmith(30, 0, 70);
            createTavern(50, 0, 30);
            createFishingSpot(-50, 0, 100);
            createMiningArea(120, 0, -80);
            createSecretCave(-200, 0, 50);
            spawnBossZones();
            createQuestNPCs();
            createCollectibles();

            // √âv√©nements
            setupControls();
            setupTouchControls();

            // Masquer l'√©cran de chargement
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 1000);

            // Activer les qu√™tes de d√©part
            startQuest('sword_quest');
            startQuest('explorer_quest');
            startQuest('collector_quest');

            // Lancer la boucle de jeu
            animate();
        }

        function getBiomeColor(x, z) {
            // D√©finir les biomes selon les zones
            if (x < -200) {
                // Biome D√©sert (ouest)
                return { r: 237, g: 201, b: 175 };
            } else if (x > 200) {
                // Biome Neige (est)
                return { r: 240, g: 248, b: 255 };
            } else if (z < -200) {
                // Biome Marais (nord)
                return { r: 85, g: 107, b: 47 };
            } else if (z > 200) {
                // Biome Montagne (sud)
                return { r: 119, g: 136, b: 153 };
            } else {
                // Biome Prairie (centre)
                const noise = Math.random() * 30;
                const green = 100 + noise;
                return { r: noise, g: green, b: noise * 0.5 };
            }
        }

        function createWorld() {
            // Terrain avec texture proc√©durale MULTI-BIOMES
            const terrainGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);

            // Canvas pour cr√©er une texture multi-biomes
            const terrainCanvas = document.createElement('canvas');
            terrainCanvas.width = 512;
            terrainCanvas.height = 512;
            const ctx = terrainCanvas.getContext('2d');

            // Texture proc√©durale avec biomes
            for (let i = 0; i < 512; i++) {
                for (let j = 0; j < 512; j++) {
                    // Convertir coordonn√©es canvas en coordonn√©es monde
                    const worldX = (i / 512) * 1000 - 500;
                    const worldZ = (j / 512) * 1000 - 500;
                    
                    const color = getBiomeColor(worldX, worldZ);
                    const noise = Math.random() * 15;
                    
                    ctx.fillStyle = `rgb(${color.r + noise}, ${color.g + noise}, ${color.b + noise})`;
                    ctx.fillRect(i, j, 1, 1);
                }
            }

            const terrainTexture = new THREE.CanvasTexture(terrainCanvas);
            terrainTexture.wrapS = THREE.RepeatWrapping;
            terrainTexture.wrapT = THREE.RepeatWrapping;
            terrainTexture.repeat.set(1, 1);

            const terrainMaterial = new THREE.MeshStandardMaterial({ 
                map: terrainTexture,
                roughness: 0.9,
                metalness: 0.1
            });

            const vertices = terrainGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 1];
                
                // Hauteur selon le biome
                let height = Math.sin(x * 0.05) * Math.cos(z * 0.05) * 4;
                
                if (x < -200) {
                    // D√©sert : plus plat avec dunes
                    height = Math.sin(x * 0.1) * 2 + Math.random() * 0.3;
                } else if (x > 200) {
                    // Neige : collines douces
                    height = Math.sin(x * 0.03) * Math.cos(z * 0.03) * 3 + Math.random() * 0.5;
                } else if (z < -200) {
                    // Marais : tr√®s plat et bas
                    height = Math.random() * 0.8 - 1;
                } else if (z > 200) {
                    // Montagne : tr√®s √©lev√© et accident√©
                    height = Math.sin(x * 0.08) * Math.cos(z * 0.08) * 12 + Math.random() * 2;
                }
                
                vertices[i + 2] = height;
            }
            terrainGeometry.computeVertexNormals();

            const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            scene.add(terrain);
            world.terrain = terrain;

            // Ciel avec d√©grad√© am√©lior√©
            const skyGeometry = new THREE.SphereGeometry(500, 64, 64);
            const vertexShader = `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            const fragmentShader = `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), 0.6), 0.0)), 1.0);
                }
            `;
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0077ff) },
                    bottomColor: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            world.sky = sky;

            // Syst√®me de particules ambiantes (papillons, poussi√®re)
            createAmbientParticles();
        }

        function createAmbientParticles() {
            const particleCount = 30;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 400;
                positions[i + 1] = Math.random() * 50 + 5;
                positions[i + 2] = (Math.random() - 0.5) * 400;

                const color = new THREE.Color();
                color.setHSL(Math.random(), 0.7, 0.7);
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function createPlayer() {
            const playerGroup = new THREE.Group();

            // Corps principal - Armure am√©lior√©e
            const bodyGeometry = new THREE.BoxGeometry(1.1, 1.5, 0.6);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2C5AA0,
                roughness: 0.4,
                metalness: 0.6,
                emissive: 0x001144,
                emissiveIntensity: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            body.receiveShadow = true;
            playerGroup.add(body);

            // Plaque d'armure sur le torse
            const chestPlateGeometry = new THREE.BoxGeometry(1.15, 1, 0.3);
            const chestPlateMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xC0C0C0,
                roughness: 0.3,
                metalness: 0.8
            });
            const chestPlate = new THREE.Mesh(chestPlateGeometry, chestPlateMaterial);
            chestPlate.position.set(0, 1.2, 0.2);
            chestPlate.castShadow = true;
            playerGroup.add(chestPlate);

            // Ornement dor√© sur l'armure
            const ornamentGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const ornamentMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                roughness: 0.3,
                metalness: 0.8,
                emissive: 0xFFD700,
                emissiveIntensity: 0.2
            });
            const ornament = new THREE.Mesh(ornamentGeometry, ornamentMaterial);
            ornament.position.set(0, 1.4, 0.4);
            playerGroup.add(ornament);

            // T√™te avec meilleur rendu
            const headGeometry = new THREE.SphereGeometry(0.45, 20, 20);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFDBBB,
                roughness: 0.7,
                metalness: 0.05
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.3;
            head.castShadow = true;
            head.receiveShadow = true;
            playerGroup.add(head);

            // Casque h√©ro√Øque
            const helmetGeometry = new THREE.SphereGeometry(0.5, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.6);
            const helmetMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B7355,
                roughness: 0.5,
                metalness: 0.6
            });
            const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
            helmet.position.y = 2.4;
            helmet.castShadow = true;
            playerGroup.add(helmet);

            // Plume d√©corative sur le casque
            const plumeGeometry = new THREE.ConeGeometry(0.1, 0.8, 8);
            const plumeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFF0000,
                roughness: 0.8
            });
            const plume = new THREE.Mesh(plumeGeometry, plumeMaterial);
            plume.position.set(0, 2.9, -0.2);
            plume.rotation.x = 0.3;
            playerGroup.add(plume);

            // Yeux brillants
            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF,
                emissive: 0x00BFFF,
                emissiveIntensity: 0.7
            });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.15, 2.35, 0.4);
            playerGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.15, 2.35, 0.4);
            playerGroup.add(rightEye);

            // Bras avec √©pauli√®res
            const armGeometry = new THREE.BoxGeometry(0.35, 1.1, 0.35);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFDBBB,
                roughness: 0.7,
                metalness: 0.1
            });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.75, 1, 0);
            leftArm.castShadow = true;
            leftArm.receiveShadow = true;
            playerGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.75, 1, 0);
            rightArm.castShadow = true;
            rightArm.receiveShadow = true;
            playerGroup.add(rightArm);

            // √âpauli√®res d'armure
            const shoulderGeometry = new THREE.SphereGeometry(0.3, 12, 12);
            const shoulderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xC0C0C0,
                roughness: 0.3,
                metalness: 0.8
            });

            const leftShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            leftShoulder.position.set(-0.75, 1.6, 0);
            leftShoulder.castShadow = true;
            playerGroup.add(leftShoulder);

            const rightShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            rightShoulder.position.set(0.75, 1.6, 0);
            rightShoulder.castShadow = true;
            playerGroup.add(rightShoulder);

            // Mains gant√©es
            const handGeometry = new THREE.BoxGeometry(0.25, 0.25, 0.25);
            const handMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.6,
                metalness: 0.2
            });

            const leftHand = new THREE.Mesh(handGeometry, handMaterial);
            leftHand.position.set(-0.75, 0.35, 0);
            leftHand.castShadow = true;
            playerGroup.add(leftHand);

            const rightHand = new THREE.Mesh(handGeometry, handMaterial);
            rightHand.position.set(0.75, 0.35, 0);
            rightHand.castShadow = true;
            playerGroup.add(rightHand);

            // Jambes avec armure
            const legGeometry = new THREE.BoxGeometry(0.45, 1.1, 0.45);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2C5AA0,
                roughness: 0.5,
                metalness: 0.5
            });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.3, 0, 0);
            leftLeg.castShadow = true;
            leftLeg.receiveShadow = true;
            playerGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.3, 0, 0);
            rightLeg.castShadow = true;
            rightLeg.receiveShadow = true;
            playerGroup.add(rightLeg);

            // Bottes
            const bootGeometry = new THREE.BoxGeometry(0.5, 0.4, 0.6);
            const bootMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.7,
                metalness: 0.3
            });

            const leftBoot = new THREE.Mesh(bootGeometry, bootMaterial);
            leftBoot.position.set(-0.3, -0.65, 0.05);
            leftBoot.castShadow = true;
            playerGroup.add(leftBoot);

            const rightBoot = new THREE.Mesh(bootGeometry, bootMaterial);
            rightBoot.position.set(0.3, -0.65, 0.05);
            rightBoot.castShadow = true;
            playerGroup.add(rightBoot);

            // Ceinture
            const beltGeometry = new THREE.BoxGeometry(1.2, 0.2, 0.65);
            const beltMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.6,
                metalness: 0.4
            });
            const belt = new THREE.Mesh(beltGeometry, beltMaterial);
            belt.position.y = 0.3;
            belt.castShadow = true;
            playerGroup.add(belt);

            // Boucle de ceinture dor√©e
            const buckleGeometry = new THREE.BoxGeometry(0.3, 0.25, 0.1);
            const buckleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                roughness: 0.2,
                metalness: 0.9
            });
            const buckle = new THREE.Mesh(buckleGeometry, buckleMaterial);
            buckle.position.set(0, 0.3, 0.4);
            buckle.castShadow = true;
            playerGroup.add(buckle);

            // Cape h√©ro√Øque
            const capeGeometry = new THREE.PlaneGeometry(1, 1.5);
            const capeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                roughness: 0.9,
                side: THREE.DoubleSide
            });
            const cape = new THREE.Mesh(capeGeometry, capeMaterial);
            cape.position.set(0, 1, -0.4);
            cape.rotation.x = 0.2;
            cape.name = 'playerCape';
            playerGroup.add(cape);

            // Aura de h√©ros am√©lior√©e
            const auraGeometry = new THREE.RingGeometry(0.9, 1.3, 32);
            const auraMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFD700,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            aura.rotation.x = -Math.PI / 2;
            aura.position.y = 0.05;
            aura.name = 'playerAura';
            playerGroup.add(aura);

            playerGroup.position.set(0, 2, 0);
            scene.add(playerGroup);
            player = playerGroup;
            playerMesh = playerGroup;
        }

        function createStartHouse(x, y, z) {
            const house = new THREE.Group();

            const wallGeometry = new THREE.BoxGeometry(12, 6, 12);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            walls.position.y = 3;
            walls.castShadow = true;
            walls.receiveShadow = true;
            house.add(walls);

            const roofGeometry = new THREE.ConeGeometry(8, 4, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x8B0000 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 8;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            house.add(roof);

            const doorGeometry = new THREE.BoxGeometry(2, 4, 0.2);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x4B3621 });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 2, 6);
            house.add(door);

            house.position.set(x, y, z);
            house.userData = { 
                type: 'start_house',
                interior: { x: x, y: y, z: z },
                hasInterior: true
            };
            scene.add(house);
            buildings.push(house);

            createSwordItem(x, y + 1.5, z);

            return { x: x, y: y, z: z };
        }

        function createSwordItem(x, y, z) {
            const swordGroup = new THREE.Group();

            const swordGeometry = new THREE.BoxGeometry(0.2, 2, 0.3);
            const swordMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
            const sword = new THREE.Mesh(swordGeometry, swordMaterial);
            sword.castShadow = true;
            swordGroup.add(sword);

            const handleGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.5, 8);
            const handleMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.y = -1;
            swordGroup.add(handle);

            swordGroup.position.set(x, y, z);
            swordGroup.rotation.z = Math.PI / 4;
            swordGroup.userData = { type: 'sword_item', name: '√âp√©e l√©gendaire' };
            scene.add(swordGroup);
            items.push(swordGroup);
        }

        function spawnAnimals() {
            for (let i = 0; i < 5; i++) {
                const x = (Math.random() - 0.5) * 400;
                const z = (Math.random() - 0.5) * 400;
                createRabbit(x, 0, z);
            }
        }

        function createRabbit(x, y, z) {
            const rabbit = new THREE.Group();

            const bodyGeometry = new THREE.SphereGeometry(0.5, 8, 6);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            rabbit.add(body);

            const headGeometry = new THREE.SphereGeometry(0.3, 8, 6);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.set(0, 0.8, 0.3);
            head.castShadow = true;
            rabbit.add(head);

            const earGeometry = new THREE.ConeGeometry(0.1, 0.5, 6);
            const leftEar = new THREE.Mesh(earGeometry, bodyMaterial);
            leftEar.position.set(-0.15, 1.2, 0.3);
            rabbit.add(leftEar);

            const rightEar = new THREE.Mesh(earGeometry, bodyMaterial);
            rightEar.position.set(0.15, 1.2, 0.3);
            rabbit.add(rightEar);

            rabbit.position.set(x, y, z);
            rabbit.userData = {
                type: 'animal',
                speed: 0.02,
                direction: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
                changeDirectionTimer: 0
            };
            scene.add(rabbit);
            animals.push(rabbit);
        }

        function createVillage(x, y, z) {
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 5; j++) {
                    if (Math.random() > 0.3) {
                        const houseX = x + i * 15 - 30;
                        const houseZ = z + j * 15 - 30;
                        createHouse(houseX, y, houseZ);

                        if (Math.random() > 0.5) {
                            createNPC(houseX + 5, y, houseZ + 5, 'Villageois', 0x8B4513);
                        }
                    }
                }
            }

            const plazaGeometry = new THREE.CircleGeometry(20, 32);
            const plazaMaterial = new THREE.MeshLambertMaterial({ color: 0xD2691E });
            const plaza = new THREE.Mesh(plazaGeometry, plazaMaterial);
            plaza.rotation.x = -Math.PI / 2;
            plaza.position.set(x, y + 0.1, z);
            plaza.receiveShadow = true;
            scene.add(plaza);

            const fountainBase = new THREE.CylinderGeometry(5, 6, 1, 16);
            const fountainMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            const fountain = new THREE.Mesh(fountainBase, fountainMaterial);
            fountain.position.set(x, y + 0.5, z);
            fountain.castShadow = true;
            scene.add(fountain);

            const waterGeometry = new THREE.CylinderGeometry(4.5, 4.5, 0.5, 16);
            const waterMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x006994,
                transparent: true,
                opacity: 0.8
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.position.set(x, y + 1, z);
            scene.add(water);
        }

        function createHouse(x, y, z) {
            const house = new THREE.Group();

            // Murs avec texture de brique
            const wallGeometry = new THREE.BoxGeometry(8, 6, 8);
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1
            });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            walls.position.y = 3;
            walls.castShadow = true;
            walls.receiveShadow = true;
            house.add(walls);

            // Toit avec tuiles
            const roofGeometry = new THREE.ConeGeometry(6, 4, 4);
            const roofMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                roughness: 0.7,
                metalness: 0.2
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 8;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            house.add(roof);

            // Porte en bois avec d√©tails
            const doorGeometry = new THREE.BoxGeometry(2, 4, 0.3);
            const doorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.8,
                metalness: 0.1
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 2, 4.1);
            door.castShadow = true;
            house.add(door);

            // Poign√©e de porte dor√©e
            const handleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const handleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                roughness: 0.3,
                metalness: 0.9,
                emissive: 0x554400,
                emissiveIntensity: 0.3
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0.8, 2, 4.3);
            house.add(handle);

            // Fen√™tres avec reflets
            const windowGeometry = new THREE.BoxGeometry(1.5, 1.5, 0.2);
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x87CEEB,
                roughness: 0.1,
                metalness: 0.9,
                transparent: true,
                opacity: 0.8
            });

            const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
            window1.position.set(2.5, 3, 4.1);
            house.add(window1);

            const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
            window2.position.set(-2.5, 3, 4.1);
            house.add(window2);

            // Chemin√©e avec fum√©e
            const chimneyGeometry = new THREE.BoxGeometry(1, 3, 1);
            const chimneyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x696969,
                roughness: 0.9
            });
            const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
            chimney.position.set(2, 8.5, 0);
            chimney.castShadow = true;
            house.add(chimney);

            // Fum√©e de chemin√©e
            createSmoke(x + 2, y + 10, z);

            house.position.set(x, y, z);
            house.userData = { 
                type: 'house',
                interior: { x: x, y: y + 1, z: z },
                hasInterior: true
            };
            scene.add(house);
            buildings.push(house);

            createInteriorDecoration(x, y, z);
        }

        function createSmoke(x, y, z) {
            const smokeGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const smokeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xCCCCCC,
                transparent: true,
                opacity: 0.5
            });

            for (let i = 0; i < 3; i++) {
                const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial.clone());
                smoke.position.set(x, y + i * 0.5, z);
                smoke.userData = {
                    type: 'smoke',
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        0.05,
                        (Math.random() - 0.5) * 0.02
                    ),
                    lifetime: 0
                };
                scene.add(smoke);
                particles.push(smoke);
            }
        }

        function createInteriorDecoration(houseX, houseY, houseZ) {
            for (let i = 0; i < 3; i++) {
                const potX = houseX + (Math.random() - 0.5) * 6;
                const potZ = houseZ + (Math.random() - 0.5) * 6;
                createPot(potX, houseY + 0.5, potZ);
            }
        }

        function createPot(x, y, z) {
            const potGeometry = new THREE.CylinderGeometry(0.3, 0.4, 0.8, 8);
            const potMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const pot = new THREE.Mesh(potGeometry, potMaterial);
            pot.position.set(x, y, z);
            pot.castShadow = true;
            pot.userData = { type: 'decoration' };
            scene.add(pot);
        }

        function createDungeon(x, y, z) {
            const entranceGeometry = new THREE.BoxGeometry(12, 10, 3);
            const entranceMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
            const entrance = new THREE.Mesh(entranceGeometry, entranceMaterial);
            entrance.position.set(x, y + 5, z);
            entrance.castShadow = true;
            scene.add(entrance);

            const doorGeometry = new THREE.BoxGeometry(4, 6, 0.5);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(x, y + 3, z + 1.5);
            door.castShadow = true;
            door.userData = { 
                type: 'dungeon_door',
                interior: { x: x, y: y + 1, z: z + 20 },
                hasInterior: true
            };
            scene.add(door);
            buildings.push(door);

            const textGeometry = new THREE.PlaneGeometry(5, 1);
            const textMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
            const textSign = new THREE.Mesh(textGeometry, textMaterial);
            textSign.position.set(x, y + 7, z + 2);
            scene.add(textSign);

            for (let i = -1; i <= 1; i += 2) {
                const torchBase = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
                const torchMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const torch = new THREE.Mesh(torchBase, torchMaterial);
                torch.position.set(x + i * 4, y + 4, z + 1.5);
                scene.add(torch);

                const flameGeometry = new THREE.SphereGeometry(0.4, 8, 8);
                const flameMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFFA500
                });
                const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                flame.position.set(x + i * 4, y + 6, z + 1.5);
                scene.add(flame);

                const torchLight = new THREE.PointLight(0xFFA500, 2, 15);
                torchLight.position.copy(flame.position);
                scene.add(torchLight);
            }

            const skullGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const skullMaterial = new THREE.MeshLambertMaterial({ color: 0xEEEEEE });
            const skull = new THREE.Mesh(skullGeometry, skullMaterial);
            skull.position.set(x, y + 1, z + 3);
            skull.castShadow = true;
            scene.add(skull);
        }

        function createDungeonInterior(x, y, z) {
            // SALLE 1 - Entr√©e avec √©nigme
            const room1Floor = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 20),
                new THREE.MeshLambertMaterial({ color: 0x2F4F4F })
            );
            room1Floor.rotation.x = -Math.PI / 2;
            room1Floor.position.set(x, y, z + 10);
            room1Floor.receiveShadow = true;
            room1Floor.userData = { type: 'interior' };
            scene.add(room1Floor);

            // Murs salle 1
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });

            const wall1Left = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            wall1Left.position.set(x - 15, y + 5, z + 10);
            wall1Left.rotation.y = Math.PI / 2;
            wall1Left.receiveShadow = true;
            wall1Left.userData = { type: 'interior' };
            scene.add(wall1Left);

            const wall1Right = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            wall1Right.position.set(x + 15, y + 5, z + 10);
            wall1Right.rotation.y = -Math.PI / 2;
            wall1Right.receiveShadow = true;
            wall1Right.userData = { type: 'interior' };
            scene.add(wall1Right);

            const wall1Back = new THREE.Mesh(new THREE.PlaneGeometry(30, 10), wallMaterial);
            wall1Back.position.set(x, y + 5, z);
            wall1Back.receiveShadow = true;
            wall1Back.userData = { type: 'interior' };
            scene.add(wall1Back);

            // √ânigme salle 1
            createPuzzle(x, y, z + 5);

            // Mini-boss salle 1
            createEnemy(x - 8, y + 1, z + 10, 'goblin');
            createEnemy(x + 8, y + 1, z + 10, 'goblin');

            // Coffre salle 1
            createChest(x - 10, y, z + 15);

            // COULOIR 1
            const corridor1Floor = new THREE.Mesh(
                new THREE.PlaneGeometry(8, 15),
                new THREE.MeshLambertMaterial({ color: 0x2F4F4F })
            );
            corridor1Floor.rotation.x = -Math.PI / 2;
            corridor1Floor.position.set(x, y, z + 27);
            corridor1Floor.receiveShadow = true;
            corridor1Floor.userData = { type: 'interior' };
            scene.add(corridor1Floor);

            const corridor1Left = new THREE.Mesh(new THREE.PlaneGeometry(15, 10), wallMaterial);
            corridor1Left.position.set(x - 4, y + 5, z + 27);
            corridor1Left.rotation.y = Math.PI / 2;
            corridor1Left.receiveShadow = true;
            corridor1Left.userData = { type: 'interior' };
            scene.add(corridor1Left);

            const corridor1Right = new THREE.Mesh(new THREE.PlaneGeometry(15, 10), wallMaterial);
            corridor1Right.position.set(x + 4, y + 5, z + 27);
            corridor1Right.rotation.y = -Math.PI / 2;
            corridor1Right.receiveShadow = true;
            corridor1Right.userData = { type: 'interior' };
            scene.add(corridor1Right);

            // Mini-boss dans le couloir
            createEnemy(x, y + 1, z + 27, 'slime');
            createEnemy(x + 2, y + 1, z + 30, 'slime');

            // SALLE 2 - Salle des tr√©sors
            const room2Floor = new THREE.Mesh(
                new THREE.PlaneGeometry(25, 20),
                new THREE.MeshLambertMaterial({ color: 0x2F4F4F })
            );
            room2Floor.rotation.x = -Math.PI / 2;
            room2Floor.position.set(x, y, z + 45);
            room2Floor.receiveShadow = true;
            room2Floor.userData = { type: 'interior' };
            scene.add(room2Floor);

            const wall2Left = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            wall2Left.position.set(x - 12.5, y + 5, z + 45);
            wall2Left.rotation.y = Math.PI / 2;
            wall2Left.receiveShadow = true;
            wall2Left.userData = { type: 'interior' };
            scene.add(wall2Left);

            const wall2Right = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            wall2Right.position.set(x + 12.5, y + 5, z + 45);
            wall2Right.rotation.y = -Math.PI / 2;
            wall2Right.receiveShadow = true;
            wall2Right.userData = { type: 'interior' };
            scene.add(wall2Right);

            // Coffres et mini-boss salle 2
            createChest(x - 8, y, z + 42);
            createChest(x + 8, y, z + 42);
            createChest(x, y, z + 48);
            createEnemy(x - 6, y + 1, z + 45, 'goblin');
            createEnemy(x + 6, y + 1, z + 45, 'goblin');

            // COULOIR 2
            const corridor2Floor = new THREE.Mesh(
                new THREE.PlaneGeometry(8, 15),
                new THREE.MeshLambertMaterial({ color: 0x2F4F4F })
            );
            corridor2Floor.rotation.x = -Math.PI / 2;
            corridor2Floor.position.set(x, y, z + 62);
            corridor2Floor.receiveShadow = true;
            corridor2Floor.userData = { type: 'interior' };
            scene.add(corridor2Floor);

            const corridor2Left = new THREE.Mesh(new THREE.PlaneGeometry(15, 10), wallMaterial);
            corridor2Left.position.set(x - 4, y + 5, z + 62);
            corridor2Left.rotation.y = Math.PI / 2;
            corridor2Left.receiveShadow = true;
            corridor2Left.userData = { type: 'interior' };
            scene.add(corridor2Left);

            const corridor2Right = new THREE.Mesh(new THREE.PlaneGeometry(15, 10), wallMaterial);
            corridor2Right.position.set(x + 4, y + 5, z + 62);
            corridor2Right.rotation.y = -Math.PI / 2;
            corridor2Right.receiveShadow = true;
            corridor2Right.userData = { type: 'interior' };
            scene.add(corridor2Right);

            // SALLE DU BOSS FINAL
            const bossFloor = new THREE.Mesh(
                new THREE.PlaneGeometry(35, 30),
                new THREE.MeshLambertMaterial({ color: 0x1a1a1a })
            );
            bossFloor.rotation.x = -Math.PI / 2;
            bossFloor.position.set(x, y, z + 85);
            bossFloor.receiveShadow = true;
            bossFloor.userData = { type: 'interior' };
            scene.add(bossFloor);

            const wallBossLeft = new THREE.Mesh(new THREE.PlaneGeometry(30, 12), wallMaterial);
            wallBossLeft.position.set(x - 17.5, y + 6, z + 85);
            wallBossLeft.rotation.y = Math.PI / 2;
            wallBossLeft.receiveShadow = true;
            wallBossLeft.userData = { type: 'interior' };
            scene.add(wallBossLeft);

            const wallBossRight = new THREE.Mesh(new THREE.PlaneGeometry(30, 12), wallMaterial);
            wallBossRight.position.set(x + 17.5, y + 6, z + 85);
            wallBossRight.rotation.y = -Math.PI / 2;
            wallBossRight.receiveShadow = true;
            wallBossRight.userData = { type: 'interior' };
            scene.add(wallBossRight);

            const wallBossBack = new THREE.Mesh(new THREE.PlaneGeometry(35, 12), wallMaterial);
            wallBossBack.position.set(x, y + 6, z + 100);
            wallBossBack.rotation.y = Math.PI;
            wallBossBack.receiveShadow = true;
            wallBossBack.userData = { type: 'interior' };
            scene.add(wallBossBack);

            // Boss final
            createEnemy(x, y + 1, z + 90, 'boss');

            // Coffres finaux
            createChest(x - 12, y, z + 95);
            createChest(x + 12, y, z + 95);

            // Plafond global
            const ceilingMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const ceiling1 = new THREE.Mesh(new THREE.PlaneGeometry(30, 20), ceilingMaterial);
            ceiling1.rotation.x = Math.PI / 2;
            ceiling1.position.set(x, y + 10, z + 10);
            ceiling1.userData = { type: 'interior' };
            scene.add(ceiling1);

            const ceiling2 = new THREE.Mesh(new THREE.PlaneGeometry(8, 15), ceilingMaterial);
            ceiling2.rotation.x = Math.PI / 2;
            ceiling2.position.set(x, y + 10, z + 27);
            ceiling2.userData = { type: 'interior' };
            scene.add(ceiling2);

            const ceiling3 = new THREE.Mesh(new THREE.PlaneGeometry(25, 20), ceilingMaterial);
            ceiling3.rotation.x = Math.PI / 2;
            ceiling3.position.set(x, y + 10, z + 45);
            ceiling3.userData = { type: 'interior' };
            scene.add(ceiling3);

            const ceiling4 = new THREE.Mesh(new THREE.PlaneGeometry(8, 15), ceilingMaterial);
            ceiling4.rotation.x = Math.PI / 2;
            ceiling4.position.set(x, y + 10, z + 62);
            ceiling4.userData = { type: 'interior' };
            scene.add(ceiling4);

            const ceiling5 = new THREE.Mesh(new THREE.PlaneGeometry(35, 30), ceilingMaterial);
            ceiling5.rotation.x = Math.PI / 2;
            ceiling5.position.set(x, y + 12, z + 85);
            ceiling5.userData = { type: 'interior' };
            scene.add(ceiling5);

            // Torches murales partout
            const torchPositions = [
                { x: x - 12, z: z + 5 }, { x: x + 12, z: z + 5 },
                { x: x - 12, z: z + 15 }, { x: x + 12, z: z + 15 },
                { x: x - 10, z: z + 42 }, { x: x + 10, z: z + 42 },
                { x: x - 10, z: z + 48 }, { x: x + 10, z: z + 48 },
                { x: x - 14, z: z + 80 }, { x: x + 14, z: z + 80 },
                { x: x - 14, z: z + 90 }, { x: x + 14, z: z + 90 }
            ];

            torchPositions.forEach(pos => {
                const torchLight = new THREE.PointLight(0xFFA500, 1.5, 12);
                torchLight.position.set(pos.x, y + 5, pos.z);
                torchLight.castShadow = true;
                torchLight.userData = { type: 'interior' };
                scene.add(torchLight);

                const flame = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xFFA500 })
                );
                flame.position.set(pos.x, y + 5, pos.z);
                flame.userData = { type: 'interior' };
                scene.add(flame);
            });
        }

        function createPuzzle(x, y, z) {
            const leverPositions = [
                { x: x - 5, z: z + 5, order: 1, color: 0xFF0000 },
                { x: x + 5, z: z + 5, order: 2, color: 0x00FF00 },
                { x: x - 5, z: z + 15, order: 3, color: 0x0000FF },
                { x: x + 5, z: z + 15, order: 4, color: 0xFFFF00 }
            ];

            leverPositions.forEach(pos => {
                const leverBase = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
                const leverMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const base = new THREE.Mesh(leverBase, leverMaterial);
                base.position.set(pos.x, y + 1, pos.z);
                base.userData = { type: 'interior' };
                scene.add(base);

                const leverHandle = new THREE.BoxGeometry(0.2, 1, 0.2);
                const handleMaterial = new THREE.MeshLambertMaterial({ color: pos.color });
                const handle = new THREE.Mesh(leverHandle, handleMaterial);
                handle.position.set(pos.x, y + 2.5, pos.z);
                handle.castShadow = true;
                handle.userData = {
                    type: 'puzzle_lever',
                    order: pos.order,
                    activated: false
                };
                scene.add(handle);
                items.push(handle);
            });
        }

        function getChunkKey(chunkX, chunkZ) {
            return `${chunkX},${chunkZ}`;
        }

        function worldToChunk(x, z) {
            return {
                x: Math.floor(x / CHUNK_SIZE),
                z: Math.floor(z / CHUNK_SIZE)
            };
        }

        function createChunk(chunkX, chunkZ) {
            const key = getChunkKey(chunkX, chunkZ);
            if (chunks.has(key)) return chunks.get(key);

            const chunk = {
                x: chunkX,
                z: chunkZ,
                objects: [],
                loaded: false
            };

            const startX = chunkX * CHUNK_SIZE;
            const startZ = chunkZ * CHUNK_SIZE;

            // G√©n√©rer la v√©g√©tation pour ce chunk
            for (let i = 0; i < 5; i++) {
                const x = startX + Math.random() * CHUNK_SIZE;
                const z = startZ + Math.random() * CHUNK_SIZE;

                if (Math.abs(x) > 20 || Math.abs(z) > 20) {
                    if (Math.abs(x - 50) > 40 || Math.abs(z - 50) > 40) {
                        const terrainHeight = getTerrainHeight(x, z);
                        let obj;
                        
                        if (x < -200) {
                            obj = createCactus(x, terrainHeight, z);
                        } else if (x > 200) {
                            obj = createSnowTree(x, terrainHeight, z);
                        } else if (z < -200) {
                            obj = createDeadTree(x, terrainHeight, z);
                        } else if (z > 200) {
                            obj = createRock(x, terrainHeight, z);
                        } else {
                            obj = createTree(x, terrainHeight, z);
                        }
                        
                        if (obj) {
                            chunk.objects.push(obj);
                            obj.visible = false; // Invisible par d√©faut
                        }
                    }
                }
            }

            chunk.loaded = true;
            chunks.set(key, chunk);
            return chunk;
        }

        function updateChunks() {
            const playerChunk = worldToChunk(player.position.x, player.position.z);

            // Si le joueur a chang√© de chunk
            if (playerChunk.x !== lastPlayerChunk.x || playerChunk.z !== lastPlayerChunk.z) {
                const newActiveChunks = new Set();

                // Charger les chunks autour du joueur
                for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
                    for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
                        const chunkX = playerChunk.x + dx;
                        const chunkZ = playerChunk.z + dz;
                        const key = getChunkKey(chunkX, chunkZ);

                        newActiveChunks.add(key);

                        // Cr√©er le chunk s'il n'existe pas
                        if (!chunks.has(key)) {
                            createChunk(chunkX, chunkZ);
                        }

                        // Rendre visible
                        const chunk = chunks.get(key);
                        if (chunk) {
                            chunk.objects.forEach(obj => {
                                if (obj) obj.visible = true;
                            });
                        }
                    }
                }

                // Masquer les chunks inactifs
                activeChunks.forEach(key => {
                    if (!newActiveChunks.has(key)) {
                        const chunk = chunks.get(key);
                        if (chunk) {
                            chunk.objects.forEach(obj => {
                                if (obj) obj.visible = false;
                            });
                        }
                    }
                });

                activeChunks = newActiveChunks;
                lastPlayerChunk = playerChunk;
            }
        }

        function createForest() {
            // La for√™t est maintenant g√©n√©r√©e dynamiquement par chunks
            // Initialiser les chunks autour du spawn
            for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
                for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
                    createChunk(dx, dz);
                }
            }
            updateChunks();
        }

        function createTree(x, y, z) {
            const tree = new THREE.Group();

            // Tronc avec texture de bois
            const trunkGeometry = new THREE.CylinderGeometry(1, 1.5, 8, 12);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 4;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            tree.add(trunk);

            // Feuillage multicouche
            const leavesGeometry = new THREE.SphereGeometry(4, 16, 12);
            const leavesMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                roughness: 0.8,
                metalness: 0.1,
                transparent: true,
                opacity: 0.9
            });

            const leaves1 = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves1.position.y = 9;
            leaves1.castShadow = true;
            leaves1.receiveShadow = true;
            leaves1.name = 'leaves';
            tree.add(leaves1);

            const leaves2 = new THREE.Mesh(
                new THREE.SphereGeometry(3, 12, 10), 
                new THREE.MeshStandardMaterial({ 
                    color: 0x32CD32,
                    roughness: 0.8,
                    transparent: true,
                    opacity: 0.8
                })
            );
            leaves2.position.y = 11;
            leaves2.castShadow = true;
            leaves2.name = 'leaves';
            tree.add(leaves2);

            // Fruits ou fleurs
            if (Math.random() > 0.5) {
                for (let i = 0; i < 5; i++) {
                    const fruitGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const fruitMaterial = new THREE.MeshStandardMaterial({ 
                        color: Math.random() > 0.5 ? 0xFF6347 : 0xFFD700,
                        roughness: 0.4,
                        metalness: 0.2,
                        emissive: 0xFF6347,
                        emissiveIntensity: 0.2
                    });
                    const fruit = new THREE.Mesh(fruitGeometry, fruitMaterial);
                    fruit.position.set(
                        (Math.random() - 0.5) * 6,
                        8 + Math.random() * 4,
                        (Math.random() - 0.5) * 6
                    );
                    fruit.castShadow = true;
                    tree.add(fruit);
                }
            }

            tree.position.set(x, y, z);
            tree.userData = { type: 'tree', windPhase: Math.random() * Math.PI * 2 };
            scene.add(tree);
            trees.push(tree);
            return tree;
        }

        function createCactus(x, y, z) {
            const cactus = new THREE.Group();
            
            // Corps principal du cactus
            const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.7, 5, 8);
            const cactusMaterial = new THREE.MeshStandardMaterial({ color: 0x2E8B57 });
            const body = new THREE.Mesh(bodyGeometry, cactusMaterial);
            body.position.y = 2.5;
            body.castShadow = true;
            cactus.add(body);

            // Bras lat√©raux
            const armGeometry = new THREE.CylinderGeometry(0.4, 0.4, 2, 8);
            const leftArm = new THREE.Mesh(armGeometry, cactusMaterial);
            leftArm.position.set(-0.8, 2, 0);
            leftArm.rotation.z = Math.PI / 4;
            leftArm.castShadow = true;
            cactus.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, cactusMaterial);
            rightArm.position.set(0.8, 3, 0);
            rightArm.rotation.z = -Math.PI / 4;
            rightArm.castShadow = true;
            cactus.add(rightArm);

            cactus.position.set(x, y, z);
            cactus.userData = { type: 'cactus', windPhase: 0 };
            scene.add(cactus);
            trees.push(cactus);
            return cactus;
        }

        function createSnowTree(x, y, z) {
            const tree = new THREE.Group();
            
            // Tronc
            const trunkGeometry = new THREE.CylinderGeometry(0.8, 1, 6, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x4B3621 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 3;
            trunk.castShadow = true;
            tree.add(trunk);

            // Feuillage en forme de sapin avec neige
            const snowGreen = 0x1C5C3D;
            for (let i = 0; i < 3; i++) {
                const coneGeometry = new THREE.ConeGeometry(3 - i * 0.7, 3, 8);
                const coneMaterial = new THREE.MeshStandardMaterial({ color: snowGreen });
                const cone = new THREE.Mesh(coneGeometry, coneMaterial);
                cone.position.y = 6 + i * 2;
                cone.castShadow = true;
                tree.add(cone);

                // Couche de neige sur chaque niveau
                const snowGeometry = new THREE.ConeGeometry(3.2 - i * 0.7, 0.5, 8);
                const snowMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const snow = new THREE.Mesh(snowGeometry, snowMaterial);
                snow.position.y = 6.8 + i * 2;
                tree.add(snow);
            }

            tree.position.set(x, y, z);
            tree.userData = { type: 'snowtree', windPhase: Math.random() * Math.PI * 2 };
            scene.add(tree);
            trees.push(tree);
            return tree;
        }

        function createDeadTree(x, y, z) {
            const tree = new THREE.Group();
            
            // Tronc mort
            const trunkGeometry = new THREE.CylinderGeometry(0.8, 1.2, 7, 8);
            const deadMaterial = new THREE.MeshStandardMaterial({ color: 0x3D3D3D });
            const trunk = new THREE.Mesh(trunkGeometry, deadMaterial);
            trunk.position.y = 3.5;
            trunk.castShadow = true;
            trunk.rotation.z = (Math.random() - 0.5) * 0.3;
            tree.add(trunk);

            // Branches mortes tordues
            for (let i = 0; i < 4; i++) {
                const branchGeometry = new THREE.CylinderGeometry(0.2, 0.3, 3, 6);
                const branch = new THREE.Mesh(branchGeometry, deadMaterial);
                const angle = (i / 4) * Math.PI * 2;
                branch.position.set(
                    Math.cos(angle) * 0.5,
                    4 + Math.random() * 2,
                    Math.sin(angle) * 0.5
                );
                branch.rotation.z = Math.random() * Math.PI * 0.5;
                branch.rotation.y = angle;
                branch.castShadow = true;
                tree.add(branch);
            }

            tree.position.set(x, y, z);
            tree.userData = { type: 'deadtree', windPhase: 0 };
            scene.add(tree);
            trees.push(tree);
            return tree;
        }

        function createRock(x, y, z) {
            const rock = new THREE.Group();
            
            // Rocher principal avec forme irr√©guli√®re
            const rockGeometry = new THREE.DodecahedronGeometry(2 + Math.random(), 0);
            const rockMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x696969,
                roughness: 0.9,
                metalness: 0.1
            });
            const mainRock = new THREE.Mesh(rockGeometry, rockMaterial);
            mainRock.position.y = 1.5;
            mainRock.castShadow = true;
            mainRock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            rock.add(mainRock);

            // Rochers secondaires
            for (let i = 0; i < 2; i++) {
                const smallRockGeometry = new THREE.DodecahedronGeometry(0.8 + Math.random() * 0.5, 0);
                const smallRock = new THREE.Mesh(smallRockGeometry, rockMaterial);
                const angle = Math.random() * Math.PI * 2;
                smallRock.position.set(
                    Math.cos(angle) * 1.5,
                    0.5,
                    Math.sin(angle) * 1.5
                );
                smallRock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                smallRock.castShadow = true;
                rock.add(smallRock);
            }

            rock.position.set(x, y, z);
            rock.userData = { type: 'rock', windPhase: 0 };
            scene.add(rock);
            trees.push(rock);
            return rock;
        }

        function createNPC(x, y, z, name, color, npcType = 'npc') {
            const npcGroup = new THREE.Group();

            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.4);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.8;
            body.castShadow = true;
            npcGroup.add(body);

            const headGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBBB });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.8;
            head.castShadow = true;
            npcGroup.add(head);

            let dialog = [
                "Bienvenue dans notre village, brave aventurier !",
                "Les monstres deviennent plus nombreux ces derniers temps...",
                "Le donjon au nord renferme de grands tr√©sors, mais aussi de terribles dangers !",
                "N'oublie pas de te nourrir r√©guli√®rement pour garder tes forces."
            ];

            if (npcType === 'merchant') {
                dialog = [
                    "üõí Bienvenue dans ma boutique !",
                    "Je vends des potions (30 Or) et de la nourriture (20 Or).",
                    "Appuyez sur C pour commercer !"
                ];
            } else if (npcType === 'quest_giver') {
                dialog = [
                    "‚öîÔ∏è Brave aventurier, j'ai des qu√™tes pour toi !",
                    "Appuyez sur Q pour voir mes missions.",
                    "De grandes r√©compenses t'attendent !"
                ];
            }

            npcGroup.position.set(x, y + 1, z);
            npcGroup.userData = { 
                type: npcType, 
                name: name,
                dialog: dialog
            };

            scene.add(npcGroup);
            npcs.push(npcGroup);
        }

        function createMerchantShop(x, y, z) {
            const shop = new THREE.Group();

            const baseGeometry = new THREE.BoxGeometry(10, 7, 10);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.8 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 3.5;
            base.castShadow = true;
            shop.add(base);

            const roofGeometry = new THREE.ConeGeometry(7, 3, 4);
            const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 8;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            shop.add(roof);

            const signGeometry = new THREE.BoxGeometry(3, 1.5, 0.2);
            const signMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(0, 6, 5.2);
            shop.add(sign);

            shop.position.set(x, y, z);
            shop.userData = { type: 'shop', hasInterior: true, interior: { x: x, y: y + 1, z: z } };
            scene.add(shop);
            buildings.push(shop);

            createNPC(x + 6, y, z, 'Marchand', 0x9370DB, 'merchant');
        }

        function createBlacksmith(x, y, z) {
            const forge = new THREE.Group();

            const baseGeometry = new THREE.BoxGeometry(12, 8, 12);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.9 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 4;
            base.castShadow = true;
            forge.add(base);

            const chimneyGeometry = new THREE.CylinderGeometry(1, 1.5, 6, 8);
            const chimneyMaterial = new THREE.MeshStandardMaterial({ color: 0x2F4F4F });
            const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
            chimney.position.set(3, 8, 0);
            chimney.castShadow = true;
            forge.add(chimney);

            createSmoke(x + 3, y + 11, z);

            const anvilGeometry = new THREE.BoxGeometry(1.5, 1, 0.8);
            const anvilMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9 });
            const anvil = new THREE.Mesh(anvilGeometry, anvilMaterial);
            anvil.position.set(x + 5, y + 0.5, z + 5);
            anvil.castShadow = true;
            scene.add(anvil);

            forge.position.set(x, y, z);
            forge.userData = { type: 'blacksmith', hasInterior: true, interior: { x: x, y: y + 1, z: z } };
            scene.add(forge);
            buildings.push(forge);

            createNPC(x + 7, y, z, 'Forgeron', 0x8B4513);
        }

        function createTavern(x, y, z) {
            const tavern = new THREE.Group();

            const baseGeometry = new THREE.BoxGeometry(15, 8, 12);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0xD2691E, roughness: 0.8 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 4;
            base.castShadow = true;
            tavern.add(base);

            const roofGeometry = new THREE.ConeGeometry(10, 4, 4);
            const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 9;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            tavern.add(roof);

            for (let i = -1; i <= 1; i++) {
                const lampPost = new THREE.CylinderGeometry(0.15, 0.15, 3, 8);
                const lamp = new THREE.Mesh(lampPost, new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
                lamp.position.set(i * 5, 1.5, 7);
                tavern.add(lamp);

                const light = new THREE.PointLight(0xFFA500, 1.5, 10);
                light.position.set(x + i * 5, y + 3, z + 7);
                scene.add(light);
            }

            tavern.position.set(x, y, z);
            tavern.userData = { type: 'tavern', hasInterior: true, interior: { x: x, y: y + 1, z: z } };
            scene.add(tavern);
            buildings.push(tavern);

            createNPC(x + 8, y, z, 'Aubergiste', 0xDC143C);
        }

        function createFishingSpot(x, y, z) {
            const pondGeometry = new THREE.CircleGeometry(15, 32);
            const pondMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1E90FF, 
                transparent: true, 
                opacity: 0.7,
                roughness: 0.2
            });
            const pond = new THREE.Mesh(pondGeometry, pondMaterial);
            pond.rotation.x = -Math.PI / 2;
            pond.position.set(x, y + 0.1, z);
            pond.userData = { type: 'fishing_spot' };
            scene.add(pond);

            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const rx = Math.cos(angle) * 16;
                const rz = Math.sin(angle) * 16;

                const reed = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 2, 8),
                    new THREE.MeshStandardMaterial({ color: 0x228B22 })
                );
                reed.position.set(x + rx, y + 1, z + rz);
                reed.castShadow = true;
                scene.add(reed);
            }

            createNPC(x + 18, y, z, 'P√™cheur', 0x4682B4);
        }

        function createMiningArea(x, y, z) {
            for (let i = 0; i < 6; i++) {
                const rockGeometry = new THREE.DodecahedronGeometry(2 + Math.random() * 2, 0);
                const rockMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x696969,
                    roughness: 0.9,
                    metalness: 0.3
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    x + (Math.random() - 0.5) * 20,
                    y + 1,
                    z + (Math.random() - 0.5) * 20
                );
                rock.castShadow = true;
                rock.userData = { type: 'mineable', health: 50, ore: Math.random() > 0.5 ? 'iron' : 'gold' };
                scene.add(rock);
                items.push(rock);
            }

            createNPC(x, y, z, 'Mineur', 0x8B4513);
        }

        function createSecretCave(x, y, z) {
            const caveEntrance = new THREE.Mesh(
                new THREE.CylinderGeometry(4, 5, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0x2F4F4F })
            );
            caveEntrance.position.set(x, y + 4, z);
            caveEntrance.rotation.x = Math.PI / 2;
            caveEntrance.castShadow = true;
            caveEntrance.userData = { type: 'cave', hasInterior: true, interior: { x: x, y: y + 1, z: z + 20 } };
            scene.add(caveEntrance);
            buildings.push(caveEntrance);

            const crystals = [];
            for (let i = 0; i < 5; i++) {
                const crystal = new THREE.Mesh(
                    new THREE.ConeGeometry(0.5, 2, 6),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00FFFF,
                        emissive: 0x00FFFF,
                        emissiveIntensity: 0.5,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                crystal.position.set(
                    x + (Math.random() - 0.5) * 8,
                    y + 1,
                    z + 5 + Math.random() * 3
                );
                crystal.castShadow = true;
                scene.add(crystal);
                crystals.push(crystal);
            }
        }

        function spawnBossZones() {
            const bossZones = [
                { x: -150, z: -150, name: 'Dragon des Glaces' },
                { x: 180, z: 180, name: 'Golem de Pierre' },
                { x: -180, z: 180, name: 'Liche Ancienne' }
            ];

            bossZones.forEach(zone => {
                const marker = new THREE.Mesh(
                    new THREE.TorusGeometry(10, 1, 16, 32),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xFF0000,
                        emissive: 0xFF0000,
                        emissiveIntensity: 0.5
                    })
                );
                marker.position.set(zone.x, 0.5, zone.z);
                marker.rotation.x = -Math.PI / 2;
                scene.add(marker);

                createEnemy(zone.x, 1, zone.z, 'boss');
            });
        }

        function createQuestNPCs() {
            const quests = [
                { x: 60, z: 40, name: 'Fermier', color: 0x8B4513, quest: 'Trouve 10 lapins perdus' },
                { x: 40, z: 60, name: 'Garde', color: 0x4169E1, quest: '√âlimine 5 gobelins' },
                { x: 55, z: 55, name: 'Sage', color: 0x9370DB, quest: 'Collecte 3 cristaux magiques' }
            ];

            quests.forEach(q => {
                const npc = new THREE.Group();

                const body = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 1.2, 0.4),
                    new THREE.MeshLambertMaterial({ color: q.color })
                );
                body.position.y = 0.8;
                body.castShadow = true;
                npc.add(body);

                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshLambertMaterial({ color: 0xFFDBBB })
                );
                head.position.y = 1.8;
                head.castShadow = true;
                npc.add(head);

                const exclamation = new THREE.Mesh(
                    new THREE.ConeGeometry(0.3, 1, 4),
                    new THREE.MeshBasicMaterial({ color: 0xFFD700 })
                );
                exclamation.position.y = 3;
                npc.add(exclamation);

                npc.position.set(q.x, 1, q.z);
                npc.userData = { type: 'quest_npc', name: q.name, quest: q.quest };
                scene.add(npc);
                npcs.push(npc);
            });
        }

        function createCollectibles() {
            const collectibles = [
                { type: 'coin', count: 15, icon: 0xFFD700 },
                { type: 'gem', count: 8, icon: 0x00FF00 },
                { type: 'artifact', count: 2, icon: 0xFF00FF }
            ];

            collectibles.forEach(c => {
                for (let i = 0; i < c.count; i++) {
                    const item = new THREE.Mesh(
                        new THREE.OctahedronGeometry(0.5, 0),
                        new THREE.MeshStandardMaterial({ 
                            color: c.icon,
                            emissive: c.icon,
                            emissiveIntensity: 0.4,
                            metalness: 0.8
                        })
                    );
                    item.position.set(
                        (Math.random() - 0.5) * 400,
                        1 + Math.random() * 2,
                        (Math.random() - 0.5) * 400
                    );
                    item.castShadow = true;
                    item.userData = { type: 'collectible', category: c.type, value: c.type === 'coin' ? 5 : c.type === 'gem' ? 20 : 100 };
                    scene.add(item);
                    items.push(item);
                }
            });
        }

        function spawnEnemies() {
            for (let i = 0; i < 8; i++) {
                const x = (Math.random() - 0.5) * 300;
                const z = (Math.random() - 0.5) * 300;

                if (Math.abs(x) > 30 || Math.abs(z) > 30) {
                    createEnemy(x, 1, z, Math.random() > 0.7 ? 'goblin' : 'slime');
                }
            }
        }

        function createEnemy(x, y, z, type) {
            const enemy = new THREE.Group();

            if (type === 'slime') {
                const slimeGeometry = new THREE.SphereGeometry(0.8, 16, 12);
                const slimeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00FF00,
                    transparent: true,
                    opacity: 0.8,
                    roughness: 0.3,
                    metalness: 0.6,
                    emissive: 0x00FF00,
                    emissiveIntensity: 0.3
                });
                const slimeBody = new THREE.Mesh(slimeGeometry, slimeMaterial);
                slimeBody.castShadow = true;
                slimeBody.receiveShadow = true;
                enemy.add(slimeBody);

                // Yeux du slime
                const eyeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.5
                });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.3, 0.3, 0.6);
                enemy.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.3, 0.3, 0.6);
                enemy.add(rightEye);

                // Lumi√®re du slime
                const slimeLight = new THREE.PointLight(0x00FF00, 1, 5);
                slimeLight.position.y = 0.5;
                enemy.add(slimeLight);

                enemy.userData = {
                    type: 'enemy',
                    enemyType: 'slime',
                    health: 30,
                    maxHealth: 30,
                    damage: 5,
                    speed: 0.02,
                    experience: 10,
                    gold: 5
                };
            } else if (type === 'goblin') {
                const bodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.3);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4B8B3B,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.5;
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);

                const headGeometry = new THREE.SphereGeometry(0.3, 12, 12);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4B8B3B,
                    roughness: 0.7
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.2;
                head.castShadow = true;
                head.receiveShadow = true;
                enemy.add(head);

                // Yeux rouges du gobelin
                const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.8
                });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.1, 1.25, 0.28);
                enemy.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.1, 1.25, 0.28);
                enemy.add(rightEye);

                enemy.userData = {
                    type: 'enemy',
                    enemyType: 'goblin',
                    health: 50,
                    maxHealth: 50,
                    damage: 10,
                    speed: 0.05,
                    experience: 20,
                    gold: 15
                };
            } else if (type === 'boss') {
                const bodyGeometry = new THREE.BoxGeometry(2, 3, 1);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B0000,
                    roughness: 0.4,
                    metalness: 0.6,
                    emissive: 0x8B0000,
                    emissiveIntensity: 0.4
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.5;
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);

                const headGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B0000,
                    roughness: 0.5,
                    metalness: 0.5,
                    emissive: 0x8B0000,
                    emissiveIntensity: 0.3
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 3.5;
                head.castShadow = true;
                head.receiveShadow = true;
                enemy.add(head);

                const hornGeometry = new THREE.ConeGeometry(0.2, 1, 8);
                const hornMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    roughness: 0.3,
                    metalness: 0.8
                });
                const leftHorn = new THREE.Mesh(hornGeometry, hornMaterial);
                leftHorn.position.set(-0.4, 4.2, 0);
                leftHorn.rotation.z = -0.3;
                leftHorn.castShadow = true;
                enemy.add(leftHorn);

                const rightHorn = new THREE.Mesh(hornGeometry, hornMaterial);
                rightHorn.position.set(0.4, 4.2, 0);
                rightHorn.rotation.z = 0.3;
                rightHorn.castShadow = true;
                enemy.add(rightHorn);

                // Aura du boss
                const auraGeometry = new THREE.RingGeometry(2, 3, 32);
                const auraMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFF0000,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                aura.rotation.x = -Math.PI / 2;
                aura.position.y = 0.1;
                aura.name = 'bossAura';
                enemy.add(aura);

                // Lumi√®re rouge du boss
                const bossLight = new THREE.PointLight(0xFF0000, 3, 15);
                bossLight.position.y = 2;
                enemy.add(bossLight);

                enemy.userData = {
                    type: 'enemy',
                    enemyType: 'boss',
                    health: 200,
                    maxHealth: 200,
                    damage: 25,
                    speed: 0.03,
                    experience: 100,
                    gold: 100
                };
            }

            enemy.position.set(x, y, z);
            scene.add(enemy);
            enemies.push(enemy);

            const healthBarGeometry = new THREE.PlaneGeometry(1, 0.1);
            const healthBarMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
            const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
            healthBar.position.y = 2.5;
            enemy.add(healthBar);
            enemy.userData.healthBar = healthBar;
        }

        function spawnChests() {
            for (let i = 0; i < 10; i++) {
                const x = (Math.random() - 0.5) * 400;
                const z = (Math.random() - 0.5) * 400;
                createChest(x, 0, z);
            }
        }

        function createChest(x, y, z) {
            const chest = new THREE.Group();

            const baseGeometry = new THREE.BoxGeometry(2, 1.5, 1.5);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.75;
            base.castShadow = true;
            chest.add(base);

            const lidGeometry = new THREE.BoxGeometry(2, 0.5, 1.5);
            const lidMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const lid = new THREE.Mesh(lidGeometry, lidMaterial);
            lid.position.y = 1.75;
            lid.castShadow = true;
            chest.add(lid);

            const lockGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.1);
            const lockMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const lock = new THREE.Mesh(lockGeometry, lockMaterial);
            lock.position.set(0, 1.2, 0.76);
            chest.add(lock);

            chest.position.set(x, y, z);
            chest.userData = {
                type: 'chest',
                opened: false,
                loot: {
                    gold: Math.floor(Math.random() * 50) + 10,
                    items: Math.random() > 0.5 ? 'potion' : 'food',
                    quantity: Math.floor(Math.random() * 3) + 1
                }
            };

            scene.add(chest);
            chests.push(chest);
        }

        function setupControls() {
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;

                if (e.key >= '1' && e.key <= '5') {
                    selectInventorySlot(parseInt(e.key) - 1);
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            document.addEventListener('click', () => {
                if (!isPointerLocked) {
                    const canvas = document.getElementById('gameCanvas');
                    try {
                        if (canvas.requestPointerLock) {
                            canvas.requestPointerLock();
                        } else if (canvas.mozRequestPointerLock) {
                            canvas.mozRequestPointerLock();
                        } else if (canvas.webkitRequestPointerLock) {
                            canvas.webkitRequestPointerLock();
                        }
                    } catch (e) {
                        console.log('Pointer lock non disponible, utilisez les touches fl√©ch√©es pour la cam√©ra');
                    }
                } else {
                    performAction();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = !!document.pointerLockElement;
            });

            document.addEventListener('mousemove', (e) => {
                if (isPointerLocked && e.movementX !== undefined) {
                    mouseX -= e.movementX * 0.002;
                    mouseY -= e.movementY * 0.002;
                    mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            document.querySelectorAll('.inventory-slot').forEach((slot, index) => {
                slot.addEventListener('click', () => selectInventorySlot(index));
            });
        }

        function setupTouchControls() {
            // D√©tection am√©lior√©e pour mobiles et tablettes
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

            if (isMobile || isTouchDevice) {
                document.getElementById('touchControls').style.display = 'block';
            }

            // Joystick gauche (d√©placement)
            const joystickLeft = document.getElementById('joystickLeft');
            const joystickKnobLeft = document.getElementById('joystickKnobLeft');

            joystickLeft.addEventListener('touchstart', handleJoystickStart.bind(null, 'left'));
            joystickLeft.addEventListener('touchmove', handleJoystickMove.bind(null, 'left', joystickLeft, joystickKnobLeft));
            joystickLeft.addEventListener('touchend', handleJoystickEnd.bind(null, 'left', joystickKnobLeft));

            // Joystick droite (cam√©ra)
            const joystickRight = document.getElementById('joystickRight');
            const joystickKnobRight = document.getElementById('joystickKnobRight');

            joystickRight.addEventListener('touchstart', handleJoystickStart.bind(null, 'right'));
            joystickRight.addEventListener('touchmove', handleJoystickMove.bind(null, 'right', joystickRight, joystickKnobRight));
            joystickRight.addEventListener('touchend', handleJoystickEnd.bind(null, 'right', joystickKnobRight));

            // Boutons d'action
            const btnJump = document.getElementById('btnJump');
            const btnAction = document.getElementById('btnAction');
            const btnInteract = document.getElementById('btnInteract');

            const btnEnter = document.getElementById('btnEnter');

            btnJump.addEventListener('touchstart', (e) => { e.preventDefault(); touchKeys['jump'] = true; });
            btnAction.addEventListener('touchstart', (e) => { e.preventDefault(); performAction(); });
            btnInteract.addEventListener('touchstart', (e) => { e.preventDefault(); checkInteractions(); });
            btnEnter.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                if (indoorMode) {
                    exitBuilding();
                } else {
                    tryEnterBuilding();
                }
            });

            btnJump.addEventListener('touchend', () => { touchKeys['jump'] = false; });
        }

        function handleJoystickStart(side, e) {
            e.preventDefault();
            if (side === 'left') {
                joystickLeftActive = true;
            } else {
                joystickRightActive = true;
            }
        }

        function handleJoystickMove(side, joystick, knob, e) {
            e.preventDefault();
            if ((side === 'left' && !joystickLeftActive) || (side === 'right' && !joystickRightActive)) return;

            const touch = e.touches[0];
            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let deltaX = touch.clientX - centerX;
            let deltaY = touch.clientY - centerY;

            const maxDistance = rect.width / 2 - 25;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (distance > maxDistance) {
                deltaX = (deltaX / distance) * maxDistance;
                deltaY = (deltaY / distance) * maxDistance;
            }

            knob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

            const normalizedX = deltaX / maxDistance;
            const normalizedY = deltaY / maxDistance;

            if (side === 'left') {
                joystickLeftVector.x = normalizedX;
                joystickLeftVector.y = normalizedY;
            } else {
                joystickRightVector.x = normalizedX;
                joystickRightVector.y = normalizedY;
            }
        }

        function handleJoystickEnd(side, knob, e) {
            e.preventDefault();
            knob.style.transform = 'translate(-50%, -50%)';

            if (side === 'left') {
                joystickLeftActive = false;
                joystickLeftVector.x = 0;
                joystickLeftVector.y = 0;
            } else {
                joystickRightActive = false;
                joystickRightVector.x = 0;
                joystickRightVector.y = 0;
            }
        }

        function selectInventorySlot(index) {
            selectedSlot = index;
            document.querySelectorAll('.inventory-slot').forEach((slot, i) => {
                slot.classList.toggle('selected', i === index);
            });
        }

        function checkInteractions() {
            const playerPos = player.position.clone();

            items.forEach((item, index) => {
                const distance = playerPos.distanceTo(item.position);

                if (item.userData.type === 'sword_item' && distance < 3) {
                    playerStats.hasSword = true;
                    scene.remove(item);
                    items.splice(index, 1);
                    inventory[0] = { type: 'weapon', name: '√âp√©e', icon: '‚öîÔ∏è', damage: 10, quantity: 1 };
                    addSwordToPlayer();
                    showMessage("Vous avez trouv√© l'√©p√©e l√©gendaire !");
                    updateInventoryUI();
                    updateQuestProgress('item', 'sword', 1);
                }

                if (item.userData.type === 'puzzle_lever' && distance < 3 && !item.userData.activated) {
                    activateLever(item);
                }

                // Collecte automatique des objets
                if (item.userData.type === 'collectible' && distance < 2) {
                    const value = item.userData.value;
                    playerStats.gold += value;
                    scene.remove(item);
                    items.splice(index, 1);
                    showMessage(`+${value} Or collect√© !`);
                    updateQuestProgress('gold', null, value);

                    // Effet visuel de collecte
                    const flash = new THREE.PointLight(0xFFD700, 3, 8);
                    flash.position.copy(item.position);
                    scene.add(flash);
                    setTimeout(() => scene.remove(flash), 200);
                }

                // Minage de rochers
                if (item.userData.type === 'mineable' && distance < 4 && keys['e'] && playerStats.hasSword) {
                    item.userData.health -= 10;
                    createDamageEffect(item.position);

                    if (item.userData.health <= 0) {
                        const ore = item.userData.ore;
                        const goldValue = ore === 'gold' ? 30 : 10;
                        playerStats.gold += goldValue;
                        scene.remove(item);
                        items.splice(index, 1);
                        showMessage(`Minerai de ${ore === 'gold' ? 'OR' : 'FER'} obtenu ! +${goldValue} Or`);
                    }
                    keys['e'] = false;
                }
            });

            // Interactions avec NPCs de qu√™te et commerce
            npcs.forEach(npc => {
                const distance = playerPos.distanceTo(npc.position);
                if (distance < 5) {
                    if (npc.userData.type === 'quest_npc') {
                        showDialog(npc.userData.name, `Qu√™te: ${npc.userData.quest}`);
                    } else if (npc.userData.type === 'merchant') {
                        showDialog(npc.userData.name, "üõí Commerce: Appuyez sur C pour acheter/vendre (Potions: 30 Or, Nourriture: 20 Or)");
                        if (keys['c']) {
                            tradeWithMerchant();
                            keys['c'] = false;
                        }
                    } else if (npc.userData.type === 'quest_giver') {
                        if (!questSystem.activeQuests.find(q => q.id === 'slayer_quest')) {
                            showDialog(npc.userData.name, "‚öîÔ∏è Appuyez sur Q pour accepter une qu√™te");
                            if (keys['q']) {
                                startQuest('slayer_quest');
                                startQuest('dungeon_master');
                                startQuest('gatherer_quest');
                                keys['q'] = false;
                            }
                        }
                    }
                }
            });
        }

        function tradeWithMerchant() {
            if (playerStats.gold >= 30) {
                playerStats.gold -= 30;
                inventory[2].quantity += 1; // Potion
                showMessage("‚úÖ Achet√© 1 Potion pour 30 Or");
            } else if (playerStats.gold >= 20) {
                playerStats.gold -= 20;
                inventory[1].quantity += 1; // Nourriture
                showMessage("‚úÖ Achet√© 1 Nourriture pour 20 Or");
            } else {
                showMessage("‚ùå Pas assez d'or !");
            }
            updateInventoryUI();
        }

        // Syst√®me de crafting simple
        function tryCrafting() {
            // Recette 1: 2 Nourritures + 1 Potion = Super Potion (soigne 100 HP)
            if (inventory[1].quantity >= 2 && inventory[2].quantity >= 1) {
                inventory[1].quantity -= 2;
                inventory[2].quantity -= 1;
                playerStats.health = Math.min(playerStats.maxHealth, playerStats.health + 100);
                showMessage("üî® Craft√©: Super Potion! +100 HP");
                updateInventoryUI();
                return true;
            }
            
            // Recette 2: 5 Pi√®ces d'or = 1 Nourriture (en cas d'urgence)
            if (playerStats.gold >= 10 && inventory[1].quantity < 10) {
                playerStats.gold -= 10;
                inventory[1].quantity += 2;
                showMessage("üî® Craft√©: 2 Nourritures");
                updateInventoryUI();
                return true;
            }
            
            showMessage("‚ùå Recettes disponibles:\n2 Nourritures + 1 Potion = Super Potion\n10 Or = 2 Nourritures");
            return false;
        }

        function checkDoorProximity() {
            const playerPos = player.position.clone();
            const btnEnter = document.getElementById('btnEnter');
            let nearBuilding = false;

            buildings.forEach(building => {
                const distance = playerPos.distanceTo(building.position);

                if (building.userData.hasInterior) {
                    if (building.userData.type === 'dungeon_door') {
                        // Donjon avec √©nigme (position -100, -100)
                        if (Math.abs(building.position.x + 100) < 1 && Math.abs(building.position.z + 100) < 1) {
                            if (!dungeonPuzzleSolved) {
                                if (distance < 12) {
                                    showMessage("Porte verrouill√©e ! R√©solvez l'√©nigme √† l'int√©rieur de la salle d'entr√©e");
                                    nearBuilding = false; // Ne pas afficher le bouton d'entr√©e
                                }
                                return;
                            }
                        }
                        if (distance < 12) {
                            showMessage("Appuyez sur E ou üö™ pour entrer dans le donjon");
                            nearBuilding = true;
                        }
                    } else {
                        if (distance < 10) {
                            showMessage("Appuyez sur E ou üö™ pour entrer");
                            nearBuilding = true;
                        }
                    }
                }
            });

            // Afficher/masquer le bouton d'entr√©e pour tablette
            if (btnEnter) {
                btnEnter.style.display = nearBuilding ? 'block' : 'none';
            }
        }

        function tryEnterBuilding() {
            const playerPos = player.position.clone();
            buildings.forEach(building => {
                if (building.userData.hasInterior) {
                    const distance = playerPos.distanceTo(building.position);
                    const maxDistance = building.userData.type === 'dungeon_door' ? 12 : 10;

                    if (distance < maxDistance) {
                        // V√©rifier si c'est le donjon verrouill√©
                        if (building.userData.type === 'dungeon_door' && 
                            Math.abs(building.position.x + 100) < 1 && 
                            Math.abs(building.position.z + 100) < 1 && 
                            !dungeonPuzzleSolved) {
                            showMessage("Cette porte est verrouill√©e ! Trouvez un autre donjon ou r√©solvez l'√©nigme");
                            return;
                        }
                        teleportToInterior(building);
                    }
                }
            });
        }

        function addSwordToPlayer() {
            const swordGeometry = new THREE.BoxGeometry(0.1, 2, 0.3);
            const swordMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
            const sword = new THREE.Mesh(swordGeometry, swordMaterial);
            sword.position.set(0.9, 1, 0);
            sword.rotation.z = -0.2;
            sword.castShadow = true;
            sword.name = 'playerSword';
            player.add(sword);
        }

        function teleportToInterior(building) {
            if (indoorMode) return;

            // Transition fade out
            const fadeOverlay = document.createElement('div');
            fadeOverlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:#000;z-index:999;opacity:0;transition:opacity 0.3s;pointer-events:none;';
            document.body.appendChild(fadeOverlay);

            setTimeout(() => fadeOverlay.style.opacity = '1', 10);

            setTimeout(() => {
                const interior = building.userData.interior;

                // Masquer √©l√©ments ext√©rieurs pour optimisation
                enemies.forEach(e => e.visible = false);
                animals.forEach(a => a.visible = false);
                trees.forEach(t => t.visible = false);
                buildings.forEach(b => { if (b !== building) b.visible = false; });
                chests.forEach(c => c.visible = false);
                npcs.forEach(n => n.visible = false);
                if (world.terrain) world.terrain.visible = false;
                if (world.sky) world.sky.visible = false;
                if (particleSystem) particleSystem.visible = false;

                if (building.userData.type === 'dungeon_door') {
                    if (!building.userData.interiorCreated) {
                        createDungeonInterior(interior.x, interior.y, interior.z);
                        building.userData.interiorCreated = true;
                    }
                    player.position.set(interior.x, interior.y + 2, interior.z + 5);
                } else if (building.userData.type === 'house' || building.userData.type === 'start_house' || 
                           building.userData.type === 'shop' || building.userData.type === 'blacksmith' || 
                           building.userData.type === 'tavern' || building.userData.type === 'cave') {
                    if (!building.userData.interiorCreated) {
                        createHouseInterior(interior.x, interior.y, interior.z, building.userData.type);
                        building.userData.interiorCreated = true;
                    }
                    player.position.set(interior.x, interior.y + 2, interior.z);
                }

                indoorMode = true;
                currentBuilding = building;

                // Afficher le bouton de sortie pour tablette
                const btnEnter = document.getElementById('btnEnter');
                if (btnEnter) btnEnter.style.display = 'block';

                // Fade in
                setTimeout(() => {
                    fadeOverlay.style.opacity = '0';
                    setTimeout(() => document.body.removeChild(fadeOverlay), 300);
                    showMessage("Appuyez sur E ou üö™ pour sortir");
                }, 100);
            }, 300);
        }

        function createHouseInterior(x, y, z, buildingType) {
            const isStartHouse = buildingType === 'start_house';
            const isShop = buildingType === 'shop';
            const isBlacksmith = buildingType === 'blacksmith';
            const isTavern = buildingType === 'tavern';
            const isCave = buildingType === 'cave';

            // Dimensions adapt√©es au type
            const roomSize = isTavern ? 14 : isCave ? 12 : 10;
            const wallHeight = isCave ? 6 : 5;

            // Sol int√©rieur avec texture adapt√©e
            const floorColor = isCave ? 0x2F4F4F : isBlacksmith ? 0x696969 : 0x8B7355;
            const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: floorColor,
                roughness: 0.9
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(x, y, z);
            floor.receiveShadow = true;
            floor.userData = { type: 'interior' };
            scene.add(floor);

            // Murs int√©rieurs avec couleur adapt√©e - visibles uniquement de l'ext√©rieur
            const wallColor = isCave ? 0x1a1a1a : isBlacksmith ? 0x4B4B4B : 0xD2B48C;
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: wallColor,
                roughness: 0.9,
                side: THREE.FrontSide
            });

            // Murs avec g√©om√©trie partag√©e pour optimisation
            const wallGeometry = new THREE.PlaneGeometry(roomSize, wallHeight);

            const wallNorth = new THREE.Mesh(wallGeometry, wallMaterial);
            wallNorth.position.set(x, y + wallHeight/2, z - roomSize/2);
            wallNorth.receiveShadow = true;
            wallNorth.userData = { type: 'interior' };
            scene.add(wallNorth);

            const wallSouth = new THREE.Mesh(wallGeometry, wallMaterial);
            wallSouth.position.set(x, y + wallHeight/2, z + roomSize/2);
            wallSouth.rotation.y = Math.PI;
            wallSouth.receiveShadow = true;
            wallSouth.userData = { type: 'interior' };
            scene.add(wallSouth);

            const wallEast = new THREE.Mesh(wallGeometry, wallMaterial);
            wallEast.position.set(x + roomSize/2, y + wallHeight/2, z);
            wallEast.rotation.y = -Math.PI / 2;
            wallEast.receiveShadow = true;
            wallEast.userData = { type: 'interior' };
            scene.add(wallEast);

            const wallWest = new THREE.Mesh(wallGeometry, wallMaterial);
            wallWest.position.set(x - roomSize/2, y + wallHeight/2, z);
            wallWest.rotation.y = Math.PI / 2;
            wallWest.receiveShadow = true;
            wallWest.userData = { type: 'interior' };
            scene.add(wallWest);

            // Plafond - visible uniquement de dessous
            const ceilingColor = isCave ? 0x000000 : isBlacksmith ? 0x2F4F4F : 0x654321;
            const ceiling = new THREE.Mesh(
                new THREE.PlaneGeometry(roomSize, roomSize), 
                new THREE.MeshStandardMaterial({ 
                    color: ceilingColor, 
                    roughness: 0.9,
                    side: THREE.BackSide
                })
            );
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(x, y + wallHeight, z);
            ceiling.userData = { type: 'interior' };
            scene.add(ceiling);

            // Lumi√®re int√©rieure adapt√©e - AM√âLIOR√âE
            const lightColor = isCave ? 0x00FFFF : isBlacksmith ? 0xFF6600 : isTavern ? 0xFFAA00 : 0xFFE4B5;
            const lightIntensity = isCave ? 1.5 : isBlacksmith ? 2.0 : 2.0;
            const interiorLight = new THREE.PointLight(lightColor, lightIntensity, roomSize * 2);
            interiorLight.position.set(x, y + wallHeight - 1, z);
            interiorLight.castShadow = true;
            interiorLight.userData = { type: 'interior' };
            scene.add(interiorLight);

            // Lumi√®re ambiante d'int√©rieur pour mieux voir
            const ambientInterior = new THREE.AmbientLight(lightColor, 0.6);
            ambientInterior.userData = { type: 'interior' };
            scene.add(ambientInterior);

            // Lumi√®res additionnelles pour toutes les pi√®ces
            const light2 = new THREE.PointLight(lightColor, lightIntensity * 0.8, 12);
            light2.position.set(x - roomSize/3, y + wallHeight - 1, z - roomSize/3);
            light2.userData = { type: 'interior' };
            scene.add(light2);

            const light3 = new THREE.PointLight(lightColor, lightIntensity * 0.8, 12);
            light3.position.set(x + roomSize/3, y + wallHeight - 1, z + roomSize/3);
            light3.userData = { type: 'interior' };
            scene.add(light3);

            // Lumi√®res lat√©rales pour √©liminer les ombres
            const light4 = new THREE.PointLight(0xFFFFFF, 0.5, 10);
            light4.position.set(x - roomSize/2 + 1, y + 2, z);
            light4.userData = { type: 'interior' };
            scene.add(light4);

            const light5 = new THREE.PointLight(0xFFFFFF, 0.5, 10);
            light5.position.set(x + roomSize/2 - 1, y + 2, z);
            light5.userData = { type: 'interior' };
            scene.add(light5);

            // MEUBLES ET D√âCORATIONS - Toujours ajout√©s
            // Table avec plateau
            const tableTop = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.2, 2),
                new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 })
            );
            tableTop.position.set(x, y + 1.5, z - 2);
            tableTop.castShadow = true;
            tableTop.receiveShadow = true;
            tableTop.userData = { type: 'interior' };
            scene.add(tableTop);

            // Pieds de table
            for (let i = -1; i <= 1; i += 2) {
                for (let j = -1; j <= 1; j += 2) {
                    const leg = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8),
                        new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 })
                    );
                    leg.position.set(x + i * 1.3, y + 0.75, z - 2 + j * 0.8);
                    leg.castShadow = true;
                    leg.receiveShadow = true;
                    leg.userData = { type: 'interior' };
                    scene.add(leg);
                }
            }

            // Chaises autour de la table
            for (let i = 0; i < 2; i++) {
                const chair = new THREE.Group();

                const seat = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.1, 0.8),
                    new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 })
                );
                seat.position.y = 0.8;
                seat.castShadow = true;
                seat.receiveShadow = true;
                chair.add(seat);

                const backrest = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 1, 0.1),
                    new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 })
                );
                backrest.position.set(0, 1.3, -0.35);
                backrest.castShadow = true;
                backrest.receiveShadow = true;
                chair.add(backrest);

                chair.position.set(x + (i === 0 ? -2 : 2), y, z - 2);
                chair.rotation.y = i === 0 ? Math.PI / 2 : -Math.PI / 2;
                chair.userData = { type: 'interior' };
                scene.add(chair);
            }

            // Lit avec cadre et matelas
            const bedFrame = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 0.5, 4),
                new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
            );
            bedFrame.position.set(x - 3, y + 0.5, z + 2);
            bedFrame.castShadow = true;
            bedFrame.receiveShadow = true;
            bedFrame.userData = { type: 'interior' };
            scene.add(bedFrame);

            const mattress = new THREE.Mesh(
                new THREE.BoxGeometry(2.3, 0.3, 3.8),
                new THREE.MeshStandardMaterial({ color: 0xFF6347, roughness: 0.7 })
            );
            mattress.position.set(x - 3, y + 0.9, z + 2);
            mattress.castShadow = true;
            mattress.receiveShadow = true;
            mattress.userData = { type: 'interior' };
            scene.add(mattress);

            // Oreiller
            const pillow = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.2, 0.6),
                new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.6 })
            );
            pillow.position.set(x - 3, y + 1.2, z + 3.2);
            pillow.castShadow = true;
            pillow.userData = { type: 'interior' };
            scene.add(pillow);

            // Coffre de rangement
            const chestInterior = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 1, 1),
                new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 })
            );
            chestInterior.position.set(x + 3.5, y + 0.5, z + 3);
            chestInterior.castShadow = true;
            chestInterior.receiveShadow = true;
            chestInterior.userData = { type: 'interior' };
            scene.add(chestInterior);

            // Couvercle du coffre
            const chestLid = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 0.2, 1),
                new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 })
            );
            chestLid.position.set(x + 3.5, y + 1.1, z + 3);
            chestLid.castShadow = true;
            chestLid.userData = { type: 'interior' };
            scene.add(chestLid);

            // Pots d√©coratifs align√©s
            for (let i = 0; i < 3; i++) {
                const pot = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.4, 0.8, 12),
                    new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 })
                );
                pot.position.set(
                    x + (i - 1) * 2,
                    y + 0.4,
                    z - 4.5
                );
                pot.castShadow = true;
                pot.receiveShadow = true;
                pot.userData = { type: 'interior' };
                scene.add(pot);
            }

            // Tapis au centre
            const rug = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 3),
                new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.9 })
            );
            rug.rotation.x = -Math.PI / 2;
            rug.position.set(x, y + 0.01, z);
            rug.receiveShadow = true;
            rug.userData = { type: 'interior' };
            scene.add(rug);

            // √âtag√®re murale
            const shelf = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.2, 0.4),
                new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 })
            );
            shelf.position.set(x + 4, y + 2.5, z - 4);
            shelf.castShadow = true;
            shelf.userData = { type: 'interior' };
            scene.add(shelf);

            // Livres sur l'√©tag√®re
            for (let i = 0; i < 3; i++) {
                const book = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.4, 0.2),
                    new THREE.MeshStandardMaterial({ 
                        color: [0xFF0000, 0x00FF00, 0x0000FF][i],
                        roughness: 0.6 
                    })
                );
                book.position.set(x + 3.5 + i * 0.4, y + 2.7, z - 4);
                book.castShadow = true;
                book.userData = { type: 'interior' };
                scene.add(book);
            }

            // Lampe sur la table
            const lampBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.2, 0.3, 8),
                new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3, metalness: 0.8 })
            );
            lampBase.position.set(x, y + 1.75, z - 2);
            lampBase.castShadow = true;
            lampBase.userData = { type: 'interior' };
            scene.add(lampBase);

            const lampShade = new THREE.Mesh(
                new THREE.ConeGeometry(0.3, 0.5, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0xFFE4B5, 
                    roughness: 0.5,
                    transparent: true,
                    opacity: 0.8
                })
            );
            lampShade.position.set(x, y + 2.15, z - 2);
            lampShade.userData = { type: 'interior' };
            scene.add(lampShade);

            // Lumi√®re de la lampe
            const lampLight = new THREE.PointLight(0xFFE4B5, 1.5, 5);
            lampLight.position.set(x, y + 2, z - 2);
            lampLight.userData = { type: 'interior' };
            scene.add(lampLight);
        }

        function activateLever(lever) {
            // V√©rifier si le levier est dans le bon ordre (1,2,3,4)
            const activatedLevers = items.filter(item => 
                item.userData.type === 'puzzle_lever' && item.userData.activated
            );

            const expectedOrder = activatedLevers.length + 1;

            if (lever.userData.order === expectedOrder) {
                lever.userData.activated = true;
                lever.rotation.x = Math.PI / 4;
                lever.material.color.setHex(0x00FF00);

                showMessage(`Levier ${lever.userData.order} activ√© correctement ! (${activatedLevers.length + 1}/4)`);

                if (activatedLevers.length + 1 === 4) {
                    dungeonPuzzleSolved = true;
                    showMessage("‚úÖ √âNIGME R√âSOLUE ! Le donjon principal est maintenant accessible !");

                    // Effet visuel de r√©ussite
                    const successLight = new THREE.PointLight(0x00FF00, 5, 30);
                    successLight.position.copy(player.position);
                    scene.add(successLight);
                    setTimeout(() => scene.remove(successLight), 2000);
                }
            } else {
                showMessage(`‚ùå Mauvais ordre ! Activez d'abord le levier ${expectedOrder}. Ordre: Rouge(1), Vert(2), Bleu(3), Jaune(4)`);

                // R√©initialiser tous les leviers
                items.forEach(item => {
                    if (item.userData.type === 'puzzle_lever') {
                        item.userData.activated = false;
                        item.rotation.x = 0;
                        if (item.userData.order === 1) item.material.color.setHex(0xFF0000);
                        if (item.userData.order === 2) item.material.color.setHex(0x00FF00);
                        if (item.userData.order === 3) item.material.color.setHex(0x0000FF);
                        if (item.userData.order === 4) item.material.color.setHex(0xFFFF00);
                    }
                });
            }
        }

        function exitBuilding() {
            // Transition fade out
            const fadeOverlay = document.createElement('div');
            fadeOverlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:#000;z-index:999;opacity:0;transition:opacity 0.3s;pointer-events:none;';
            document.body.appendChild(fadeOverlay);

            setTimeout(() => fadeOverlay.style.opacity = '1', 10);

            setTimeout(() => {
                // Nettoyer int√©rieur
                const interiorObjects = scene.children.filter(obj => obj.userData.type === 'interior');
                interiorObjects.forEach(obj => scene.remove(obj));

                // Repositionner joueur
                player.position.set(
                    currentBuilding.position.x,
                    currentBuilding.position.y + 2,
                    currentBuilding.position.z + 8
                );

                // Restaurer monde ext√©rieur
                enemies.forEach(e => e.visible = true);
                animals.forEach(a => a.visible = true);
                trees.forEach(t => t.visible = true);
                buildings.forEach(b => b.visible = true);
                chests.forEach(c => c.visible = true);
                npcs.forEach(n => n.visible = true);
                if (world.terrain) world.terrain.visible = true;
                if (world.sky) world.sky.visible = true;
                if (particleSystem) particleSystem.visible = true;

                // R√©initialiser le marqueur de position cam√©ra
                if (currentBuilding) {
                    currentBuilding.userData.cameraPositionSet = false;
                }

                indoorMode = false;
                currentBuilding = null;

                // Masquer le bouton d'entr√©e
                const btnEnter = document.getElementById('btnEnter');
                if (btnEnter) btnEnter.style.display = 'none';

                // Fade in
                setTimeout(() => {
                    fadeOverlay.style.opacity = '0';
                    setTimeout(() => document.body.removeChild(fadeOverlay), 300);
                    showMessage("Vous √™tes sorti");
                }, 100);
            }, 300);
        }

        function performAction() {
            if (!playerStats.hasSword) {
                showMessage("Vous avez besoin d'une arme !");
                return;
            }

            // Animation d'attaque avec l'√©p√©e
            const sword = player.getObjectByName('playerSword');
            if (sword) {
                const originalRotation = sword.rotation.z;
                sword.rotation.z = -Math.PI / 2;
                setTimeout(() => {
                    sword.rotation.z = originalRotation;
                }, 200);
            }

            const playerPos = player.position.clone();

            enemies.forEach((enemy, index) => {
                const distance = playerPos.distanceTo(enemy.position);
                if (distance < 5) {
                    enemy.userData.health -= playerStats.damage;

                    createDamageEffect(enemy.position);

                    if (enemy.userData.health <= 0) {
                        defeatedEnemy(enemy, index);
                    }
                }
            });

            chests.forEach(chest => {
                const distance = playerPos.distanceTo(chest.position);
                if (distance < 4 && !chest.userData.opened) {
                    openChest(chest);
                }
            });

            npcs.forEach(npc => {
                const distance = playerPos.distanceTo(npc.position);
                if (distance < 5) {
                    showDialog(npc.userData.name, npc.userData.dialog[Math.floor(Math.random() * npc.userData.dialog.length)]);
                }
            });
        }

        function defeatedEnemy(enemy, index) {
            playerStats.experience += enemy.userData.experience;
            playerStats.gold += enemy.userData.gold;

            if (playerStats.experience >= playerStats.level * 100) {
                levelUp();
            }

            scene.remove(enemy);
            enemies.splice(index, 1);

            showMessage(`+${enemy.userData.experience} XP, +${enemy.userData.gold} Or`);
            
            // Mise √† jour qu√™tes
            updateQuestProgress('kill', enemy.userData.enemyType, 1);
            updateQuestProgress('gold', null, enemy.userData.gold);

            updateUI();
        }

        function openChest(chest) {
            chest.userData.opened = true;

            const lid = chest.children[1];
            lid.rotation.x = -Math.PI / 4;

            const loot = chest.userData.loot;
            playerStats.gold += loot.gold;

            if (loot.items === 'potion') {
                inventory[2].quantity += loot.quantity;
            } else if (loot.items === 'food') {
                inventory[1].quantity += loot.quantity;
            }

            showMessage(`Coffre ouvert ! +${loot.gold} Or, +${loot.quantity} ${loot.items}`);
            updateQuestProgress('chest', null, 1);
            updateQuestProgress('gold', null, loot.gold);
            updateUI();
        }

        function levelUp() {
            playerStats.level++;
            playerStats.maxHealth += 20;
            playerStats.health = playerStats.maxHealth;
            playerStats.damage += 5;
            playerStats.defense += 2;

            showMessage(`NIVEAU ${playerStats.level} !`);

            const levelUpEffect = new THREE.PointLight(0xFFD700, 5, 20);
            levelUpEffect.position.copy(player.position);
            scene.add(levelUpEffect);
            setTimeout(() => scene.remove(levelUpEffect), 1000);
        }

        function createDamageEffect(position) {
            // Particules de sang/d√©g√¢ts
            const particleGeometry = new THREE.SphereGeometry(0.15, 6, 6);

            for (let i = 0; i < 8; i++) {
                const particleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.4,
                    (Math.random() - 0.5) * 0.3
                );
                particle.castShadow = true;
                scene.add(particle);
                particles.push(particle);

                setTimeout(() => {
                    scene.remove(particle);
                    particles = particles.filter(p => p !== particle);
                }, 1000);
            }

            // Flash lumineux
            const flashLight = new THREE.PointLight(0xFF0000, 5, 10);
            flashLight.position.copy(position);
            scene.add(flashLight);
            setTimeout(() => scene.remove(flashLight), 100);

            // Onde de choc
            const shockGeometry = new THREE.RingGeometry(0.5, 1, 32);
            const shockMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFF00,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const shock = new THREE.Mesh(shockGeometry, shockMaterial);
            shock.position.copy(position);
            shock.rotation.x = -Math.PI / 2;
            scene.add(shock);

            let scale = 1;
            const shockInterval = setInterval(() => {
                scale += 0.3;
                shock.scale.set(scale, scale, 1);
                shock.material.opacity -= 0.1;
                if (shock.material.opacity <= 0) {
                    scene.remove(shock);
                    clearInterval(shockInterval);
                }
            }, 50);
        }

        function showMessage(text) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.style.display = 'block';
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 2000);
        }

        function showDialog(speaker, text) {
            const dialogBox = document.getElementById('dialogBox');
            const dialogSpeaker = document.getElementById('dialogSpeaker');
            const dialogText = document.getElementById('dialogText');

            dialogSpeaker.textContent = speaker;
            dialogText.textContent = text;
            dialogBox.style.display = 'block';

            setTimeout(() => {
                dialogBox.style.display = 'none';
            }, 5000);
        }

        function updateUI() {
            document.getElementById('healthFill').style.width = (playerStats.health / playerStats.maxHealth * 100) + '%';
            document.getElementById('hungerFill').style.width = (playerStats.hunger / playerStats.maxHunger * 100) + '%';
            document.getElementById('experienceFill').style.width = ((playerStats.experience % 100) / 100 * 100) + '%';

            document.getElementById('level').textContent = playerStats.level;
            document.getElementById('gold').textContent = playerStats.gold;
            document.getElementById('position').textContent = `${Math.round(player.position.x)}, ${Math.round(player.position.z)}`;

            const hour = Math.floor(gameTime / 1000) % 24;
            document.getElementById('gameTime').textContent = hour < 6 || hour > 20 ? 'Nuit' : 'Jour';

            updateInventoryUI();
        }

        function updateInventoryUI() {
            const slots = document.querySelectorAll('.inventory-slot');
            inventory.forEach((item, index) => {
                if (slots[index]) {
                    slots[index].innerHTML = item.icon;
                    if (item.quantity > 1) {
                        const count = document.createElement('span');
                        count.className = 'item-count';
                        count.textContent = item.quantity;
                        slots[index].appendChild(count);
                    }
                }
            });
        }

        function updateMinimap() {
            const minimapCanvas = document.getElementById('minimapCanvas');
            const ctx = minimapCanvas.getContext('2d');
            const size = 150;
            minimapCanvas.width = size;
            minimapCanvas.height = size;

            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, size, size);

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= 10; i++) {
                ctx.beginPath();
                ctx.moveTo(i * size / 10, 0);
                ctx.lineTo(i * size / 10, size);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * size / 10);
                ctx.lineTo(size, i * size / 10);
                ctx.stroke();
            }

            const playerX = size / 2 + player.position.x * 0.5;
            const playerZ = size / 2 + player.position.z * 0.5;

            ctx.fillStyle = '#00FF00';
            ctx.beginPath();
            ctx.arc(playerX, playerZ, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FF0000';
            enemies.forEach(enemy => {
                const enemyX = size / 2 + enemy.position.x * 0.5;
                const enemyZ = size / 2 + enemy.position.z * 0.5;
                if (enemyX >= 0 && enemyX <= size && enemyZ >= 0 && enemyZ <= size) {
                    ctx.beginPath();
                    ctx.arc(enemyX, enemyZ, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.fillStyle = '#FFD700';
            chests.forEach(chest => {
                if (!chest.userData.opened) {
                    const chestX = size / 2 + chest.position.x * 0.5;
                    const chestZ = size / 2 + chest.position.z * 0.5;
                    if (chestX >= 0 && chestX <= size && chestZ >= 0 && chestZ <= size) {
                        ctx.fillRect(chestX - 2, chestZ - 2, 4, 4);
                    }
                }
            });
        }

        function getTerrainHeight(x, z) {
            // Calculer la hauteur du terrain √† une position donn√©e (m√™me formule que la g√©n√©ration)
            let height = Math.sin(x * 0.05) * Math.cos(z * 0.05) * 4;
            
            if (x < -200) {
                // D√©sert : plus plat avec dunes
                height = Math.sin(x * 0.1) * 2;
            } else if (x > 200) {
                // Neige : collines douces
                height = Math.sin(x * 0.03) * Math.cos(z * 0.03) * 3;
            } else if (z < -200) {
                // Marais : tr√®s plat et bas
                height = -0.5;
            } else if (z > 200) {
                // Montagne : tr√®s √©lev√© et accident√©
                height = Math.sin(x * 0.08) * Math.cos(z * 0.08) * 12;
            }
            
            return height;
        }

        function checkBiomeExploration() {
            const x = player.position.x;
            const z = player.position.z;
            
            if (x < -200 && !questSystem.biomesVisited?.desert) {
                if (!questSystem.biomesVisited) questSystem.biomesVisited = {};
                questSystem.biomesVisited.desert = true;
                updateQuestProgress('biome', 'desert');
                showMessage('üèúÔ∏è Biome D√©sert d√©couvert !');
            } else if (x > 200 && !questSystem.biomesVisited?.snow) {
                if (!questSystem.biomesVisited) questSystem.biomesVisited = {};
                questSystem.biomesVisited.snow = true;
                updateQuestProgress('biome', 'snow');
                showMessage('‚ùÑÔ∏è Biome Neige d√©couvert !');
            } else if (z < -200 && !questSystem.biomesVisited?.swamp) {
                if (!questSystem.biomesVisited) questSystem.biomesVisited = {};
                questSystem.biomesVisited.swamp = true;
                updateQuestProgress('biome', 'swamp');
                showMessage('üåø Biome Marais d√©couvert !');
            } else if (z > 200 && !questSystem.biomesVisited?.mountain) {
                if (!questSystem.biomesVisited) questSystem.biomesVisited = {};
                questSystem.biomesVisited.mountain = true;
                updateQuestProgress('biome', 'mountain');
                showMessage('‚õ∞Ô∏è Biome Montagne d√©couvert !');
            }
        }

        function handleMovement() {
            const moveSpeed = playerStats.speed;
            const direction = new THREE.Vector3();
            
            // V√©rifier l'exploration de biomes
            if (!indoorMode) {
                checkBiomeExploration();
            }

            // Support clavier
            if (keys['z'] || keys['w']) direction.z -= 1;
            if (keys['s']) direction.z += 1;
            if (keys['q'] || keys['a']) direction.x -= 1;
            if (keys['d']) direction.x += 1;

            // Support joystick gauche pour d√©placement
            if (joystickLeftActive) {
                direction.x += joystickLeftVector.x;
                direction.z += joystickLeftVector.y;
            }

            // D√©tection du mouvement pour les animations
            isPlayerMoving = direction.length() > 0;

            // Contr√¥les cam√©ra clavier
            if (keys['arrowleft']) {
                mouseX += 0.05;
            }
            if (keys['arrowright']) {
                mouseX -= 0.05;
            }
            if (keys['arrowup']) {
                mouseY = Math.min(Math.PI/2, mouseY + 0.05);
            }
            if (keys['arrowdown']) {
                mouseY = Math.max(-Math.PI/2, mouseY - 0.05);
            }

            // Support joystick droite pour cam√©ra
            if (joystickRightActive) {
                mouseX -= joystickRightVector.x * 0.05;
                mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY - joystickRightVector.y * 0.05));
            }

            direction.normalize();

            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), mouseX);

            velocity.x = direction.x * moveSpeed;
            velocity.z = direction.z * moveSpeed;

            if ((keys[' '] || touchKeys['jump']) && canJump) {
                velocity.y = playerStats.jumpPower;
                canJump = false;
                touchKeys['jump'] = false;
            }

            velocity.y -= 0.01;

            // Sauvegarder la position avant d√©placement pour collision
            const oldPosition = player.position.clone();
            player.position.add(velocity);

            // V√©rifier les collisions
            let collision = false;

            if (indoorMode && currentBuilding) {
                // Collisions dans les donjons et b√¢timents
                const interior = currentBuilding.userData.interior;

                if (currentBuilding.userData.type === 'dungeon_door') {
                    // Limites du donjon - Salle 1
                    if (player.position.z < interior.z + 2) {
                        player.position.z = interior.z + 2;
                        collision = true;
                    }
                    if (player.position.z > interior.z + 18 && player.position.z < interior.z + 22) {
                        if (player.position.x < interior.x - 14 || player.position.x > interior.x + 14) {
                            player.position.x = oldPosition.x;
                            collision = true;
                        }
                    }

                    // Couloir 1
                    if (player.position.z > interior.z + 20 && player.position.z < interior.z + 35) {
                        if (player.position.x < interior.x - 3 || player.position.x > interior.x + 3) {
                            player.position.x = oldPosition.x;
                            collision = true;
                        }
                    }

                    // Salle 2
                    if (player.position.z > interior.z + 35 && player.position.z < interior.z + 55) {
                        if (player.position.x < interior.x - 11 || player.position.x > interior.x + 11) {
                            player.position.x = oldPosition.x;
                            collision = true;
                        }
                    }

                    // Couloir 2
                    if (player.position.z > interior.z + 55 && player.position.z < interior.z + 70) {
                        if (player.position.x < interior.x - 3 || player.position.x > interior.x + 3) {
                            player.position.x = oldPosition.x;
                            collision = true;
                        }
                    }

                    // Salle du boss
                    if (player.position.z > interior.z + 70 && player.position.z < interior.z + 98) {
                        if (player.position.x < interior.x - 16 || player.position.x > interior.x + 16) {
                            player.position.x = oldPosition.x;
                            collision = true;
                        }
                    }

                    // Limite arri√®re
                    if (player.position.z > interior.z + 98) {
                        player.position.z = interior.z + 98;
                        collision = true;
                    }
                } else {
                    // Collisions pour maisons et autres b√¢timents
                    const roomSize = currentBuilding.userData.type === 'tavern' ? 14 : 
                                    currentBuilding.userData.type === 'cave' ? 12 : 10;
                    const halfSize = roomSize / 2 - 0.5;

                    if (player.position.x < interior.x - halfSize) {
                        player.position.x = interior.x - halfSize;
                        collision = true;
                    }
                    if (player.position.x > interior.x + halfSize) {
                        player.position.x = interior.x + halfSize;
                        collision = true;
                    }
                    if (player.position.z < interior.z - halfSize) {
                        player.position.z = interior.z - halfSize;
                        collision = true;
                    }
                    if (player.position.z > interior.z + halfSize) {
                        player.position.z = interior.z + halfSize;
                        collision = true;
                    }
                }
            }

            // Collision avec les b√¢timents √† l'ext√©rieur - AM√âLIOR√â
            if (!indoorMode) {
                buildings.forEach(building => {
                    const bx = building.position.x;
                    const bz = building.position.z;
                    const by = building.position.y;
                    
                    // Taille de collision ajust√©e selon le type
                    let sizeX = 5;
                    let sizeZ = 5;
                    let sizeY = 7;
                    
                    if (building.userData.type === 'dungeon_door') {
                        sizeX = 7;
                        sizeZ = 4;
                        sizeY = 10;
                    } else if (building.userData.type === 'shop' || building.userData.type === 'tavern') {
                        sizeX = 6;
                        sizeZ = 6;
                    } else if (building.userData.type === 'blacksmith') {
                        sizeX = 7;
                        sizeZ = 7;
                    }

                    // Collision 3D avec les b√¢timents
                    if (Math.abs(player.position.x - bx) < sizeX && 
                        Math.abs(player.position.z - bz) < sizeZ &&
                        player.position.y < by + sizeY) {
                        player.position.x = oldPosition.x;
                        player.position.z = oldPosition.z;
                        collision = true;
                    }
                });

                // Collision avec les arbres - AM√âLIOR√âE
                trees.forEach(tree => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - tree.position.x, 2) + 
                        Math.pow(player.position.z - tree.position.z, 2)
                    );
                    if (distance < 1.8) {
                        player.position.x = oldPosition.x;
                        player.position.z = oldPosition.z;
                        collision = true;
                    }
                });

                // Collision avec les coffres
                chests.forEach(chest => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - chest.position.x, 2) + 
                        Math.pow(player.position.z - chest.position.z, 2)
                    );
                    if (distance < 1.5) {
                        player.position.x = oldPosition.x;
                        player.position.z = oldPosition.z;
                        collision = true;
                    }
                });

                // Collision avec les NPCs
                npcs.forEach(npc => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - npc.position.x, 2) + 
                        Math.pow(player.position.z - npc.position.z, 2)
                    );
                    if (distance < 1.2) {
                        player.position.x = oldPosition.x;
                        player.position.z = oldPosition.z;
                        collision = true;
                    }
                });
            }

            // PHYSIQUE CORRIG√âE - Le joueur touche vraiment le sol
            if (!indoorMode) {
                const terrainHeight = getTerrainHeight(player.position.x, player.position.z);
                const groundLevel = terrainHeight + 0.5; // R√©duit de 2 √† 0.5 pour que le joueur touche le sol
                
                if (player.position.y <= groundLevel) {
                    player.position.y = groundLevel;
                    velocity.y = 0;
                    canJump = true;
                }
            } else {
                // √Ä l'int√©rieur, sol plat
                const interior = currentBuilding.userData.interior;
                const groundLevel = interior.y + 0.5; // R√©duit aussi pour l'int√©rieur
                
                if (player.position.y <= groundLevel) {
                    player.position.y = groundLevel;
                    velocity.y = 0;
                    canJump = true;
                }
            }

            player.position.x = Math.max(-490, Math.min(490, player.position.x));
            player.position.z = Math.max(-490, Math.min(490, player.position.z));

            player.rotation.y = mouseX + Math.PI;

            // ANIMATIONS TR√àS AM√âLIOR√âES du personnage
            const leftArm = player.children.find(c => c.position.x < 0 && c.geometry instanceof THREE.BoxGeometry && c.geometry.parameters.width === 0.35);
            const rightArm = player.children.find(c => c.position.x > 0 && c.geometry instanceof THREE.BoxGeometry && c.geometry.parameters.width === 0.35);
            const leftLeg = player.children.find(c => c.position.x < 0 && c.geometry instanceof THREE.BoxGeometry && c.geometry.parameters.width === 0.45);
            const rightLeg = player.children.find(c => c.position.x > 0 && c.geometry instanceof THREE.BoxGeometry && c.geometry.parameters.width === 0.45);
            const body = player.children.find(c => c.geometry instanceof THREE.BoxGeometry && c.geometry.parameters.height === 1.5);
            const head = player.children.find(c => c.geometry instanceof THREE.SphereGeometry && c.position.y > 2);
            const cape = player.getObjectByName('playerCape');

            if (isPlayerMoving) {
                // Animation de marche tr√®s fluide et r√©aliste
                walkAnimationTime += 0.2;

                // Balancement des bras plus prononc√© et naturel
                if (leftArm) {
                    leftArm.rotation.x = Math.sin(walkAnimationTime) * 0.8;
                    leftArm.rotation.z = Math.sin(walkAnimationTime * 0.3) * 0.15;
                    leftArm.position.y = 1 + Math.abs(Math.sin(walkAnimationTime)) * 0.05;
                }
                if (rightArm) {
                    rightArm.rotation.x = Math.sin(walkAnimationTime + Math.PI) * 0.8;
                    rightArm.rotation.z = -Math.sin(walkAnimationTime * 0.3) * 0.15;
                    rightArm.position.y = 1 + Math.abs(Math.sin(walkAnimationTime + Math.PI)) * 0.05;
                }
                
                // Mouvement des jambes plus prononc√©
                if (leftLeg) {
                    leftLeg.rotation.x = Math.sin(walkAnimationTime + Math.PI) * 0.6;
                    leftLeg.position.y = Math.abs(Math.sin(walkAnimationTime + Math.PI)) * 0.08;
                }
                if (rightLeg) {
                    rightLeg.rotation.x = Math.sin(walkAnimationTime) * 0.6;
                    rightLeg.position.y = Math.abs(Math.sin(walkAnimationTime)) * 0.08;
                }

                // Balancement du corps plus visible
                if (body) {
                    body.rotation.z = Math.sin(walkAnimationTime * 0.5) * 0.08;
                    body.rotation.x = Math.sin(walkAnimationTime * 0.3) * 0.05;
                    body.position.y = 1 + Math.abs(Math.sin(walkAnimationTime * 2)) * 0.05;
                }

                // Balancement de la t√™te coordonn√©
                if (head) {
                    head.rotation.z = Math.sin(walkAnimationTime * 0.5) * 0.1;
                    head.rotation.x = Math.sin(walkAnimationTime * 0.4) * 0.06;
                    head.position.y = 2.3 + Math.abs(Math.sin(walkAnimationTime * 2)) * 0.03;
                }
                
                // Animation de la cape qui suit le mouvement
                if (cape) {
                    cape.rotation.x = 0.2 + Math.sin(walkAnimationTime * 0.7) * 0.15;
                    cape.rotation.y = Math.sin(walkAnimationTime * 0.5) * 0.1;
                }
            } else {
                // Animation idle plus vivante
                const idleTime = Date.now() * 0.001;

                if (leftArm) {
                    leftArm.rotation.x = Math.sin(idleTime * 0.8) * 0.1;
                    leftArm.rotation.z = Math.sin(idleTime * 0.5) * 0.05;
                    leftArm.position.y = 1;
                }
                if (rightArm) {
                    rightArm.rotation.x = Math.sin(idleTime * 0.8 + Math.PI) * 0.1;
                    rightArm.rotation.z = -Math.sin(idleTime * 0.5) * 0.05;
                    rightArm.position.y = 1;
                }
                if (leftLeg) {
                    leftLeg.rotation.x = 0;
                    leftLeg.position.y = 0;
                }
                if (rightLeg) {
                    rightLeg.rotation.x = 0;
                    rightLeg.position.y = 0;
                }

                if (body) {
                    body.rotation.z = Math.sin(idleTime * 0.6) * 0.04;
                    body.rotation.x = Math.sin(idleTime * 0.4) * 0.02;
                    body.position.y = 1 + Math.abs(Math.sin(idleTime * 1.5)) * 0.02;
                }

                if (head) {
                    head.rotation.z = Math.sin(idleTime * 0.5) * 0.05;
                    head.rotation.x = Math.sin(idleTime * 0.3) * 0.03;
                    head.rotation.y = Math.sin(idleTime * 0.25) * 0.08;
                    head.position.y = 2.3 + Math.abs(Math.sin(idleTime * 1.5)) * 0.015;
                }
                
                // Cape qui bouge doucement m√™me √† l'arr√™t
                if (cape) {
                    cape.rotation.x = 0.2 + Math.sin(idleTime * 0.8) * 0.05;
                    cape.rotation.y = Math.sin(idleTime * 0.6) * 0.03;
                }
            }

            // Animation am√©lior√©e de l'√©p√©e
            const sword = player.getObjectByName('playerSword');
            if (sword) {
                if (isPlayerMoving) {
                    sword.rotation.y = Math.sin(walkAnimationTime * 0.8) * 0.4;
                    sword.rotation.z = -0.2 + Math.sin(walkAnimationTime * 0.5) * 0.15;
                    sword.position.x = 0.9 + Math.sin(walkAnimationTime) * 0.05;
                } else {
                    const idleTime = Date.now() * 0.001;
                    sword.rotation.y = Math.sin(idleTime * 0.7) * 0.2;
                    sword.rotation.z = -0.2 + Math.sin(idleTime * 0.5) * 0.05;
                    sword.position.x = 0.9;
                }
            }

            // V√©rifier la proximit√© des portes
            if (!indoorMode) {
                checkDoorProximity();

                // Entr√©e dans les b√¢timents avec touche E - BUG CORRIG√â
                if (keys['e']) {
                    let enteredBuilding = false;
                    const playerPos = player.position.clone();
                    buildings.forEach(building => {
                        if (building.userData.hasInterior && !enteredBuilding) {
                            const distance = playerPos.distanceTo(building.position);
                            const maxDistance = building.userData.type === 'dungeon_door' ? 12 : 10;
                            
                            if (distance < maxDistance) {
                                // V√©rifier si c'est le donjon verrouill√©
                                if (building.userData.type === 'dungeon_door' && 
                                    Math.abs(building.position.x + 100) < 1 && 
                                    Math.abs(building.position.z + 100) < 1 && 
                                    !dungeonPuzzleSolved) {
                                    showMessage("Cette porte est verrouill√©e !");
                                } else {
                                    teleportToInterior(building);
                                    enteredBuilding = true;
                                }
                                keys['e'] = false;
                            }
                        }
                    });
                    
                    // Si on n'est pas entr√© dans un b√¢timent, faire les autres interactions
                    if (!enteredBuilding) {
                        checkInteractions();
                    }
                    keys['e'] = false;
                }
            } else if (keys['e']) {
                // Si on est √† l'int√©rieur, E permet de sortir
                exitBuilding();
                keys['e'] = false;
            }

            // Crafting
            if (keys['f']) {
                tryCrafting();
                keys['f'] = false;
            }
        }

        function updateCamera() {
            if (indoorMode && currentBuilding) {
                // Cam√©ra FIXE √† l'int√©rieur - ne bouge PAS, suit juste du regard
                const interior = currentBuilding.userData.interior;
                const roomSize = currentBuilding.userData.type === 'tavern' ? 14 : 
                                currentBuilding.userData.type === 'cave' ? 12 : 10;
                
                // Position FIXE de la cam√©ra (d√©finie une seule fois lors de l'entr√©e)
                if (!currentBuilding.userData.cameraPositionSet) {
                    camera.position.set(
                        interior.x,
                        interior.y + 4,
                        interior.z - roomSize * 0.3
                    );
                    currentBuilding.userData.cameraPositionSet = true;
                }
                
                // La cam√©ra reste IMMOBILE mais REGARDE le personnage
                const lookAtTarget = new THREE.Vector3(
                    player.position.x, 
                    player.position.y + 1, 
                    player.position.z
                );
                camera.lookAt(lookAtTarget);
            } else {
                // Vue ext√©rieure - cam√©ra suit le personnage
                let cameraDistance = 10;
                let cameraHeight = 5;

                const targetX = player.position.x + Math.sin(mouseX) * cameraDistance;
                const targetY = player.position.y + cameraHeight - mouseY * 5;
                const targetZ = player.position.z + Math.cos(mouseX) * cameraDistance;

                // Interpolation pour un mouvement fluide
                camera.position.x += (targetX - camera.position.x) * 0.15;
                camera.position.y += (targetY - camera.position.y) * 0.15;
                camera.position.z += (targetZ - camera.position.z) * 0.15;

                const lookAtTarget = new THREE.Vector3(
                    player.position.x,
                    player.position.y + 1.5,
                    player.position.z
                );
                camera.lookAt(lookAtTarget);
            }
        }

        function updateEnemies() {
            enemies.forEach(enemy => {
                const distance = player.position.distanceTo(enemy.position);

                if (distance < 20) {
                    const direction = new THREE.Vector3();
                    direction.subVectors(player.position, enemy.position);
                    direction.y = 0;
                    direction.normalize();

                    enemy.position.add(direction.multiplyScalar(enemy.userData.speed));
                    enemy.lookAt(player.position);

                    // Animation de saut en approchant
                    enemy.position.y = 1 + Math.abs(Math.sin(Date.now() * 0.01)) * 0.5;

                    if (distance < 2) {
                        playerStats.health -= enemy.userData.damage * 0.01;
                        playerStats.health = Math.max(0, playerStats.health);

                        if (playerStats.health <= 0) {
                            gameOver();
                        }
                    }
                } else {
                    enemy.position.x += (Math.random() - 0.5) * 0.05;
                    enemy.position.z += (Math.random() - 0.5) * 0.05;

                    // Animation de rebondissement quand inactif
                    enemy.position.y = 1 + Math.sin(Date.now() * 0.003 + enemy.position.x) * 0.2;
                }

                // Animation de l'aura du boss
                const bossAura = enemy.getObjectByName('bossAura');
                if (bossAura) {
                    bossAura.rotation.z += 0.02;
                    bossAura.material.opacity = 0.3 + Math.sin(Date.now() * 0.003) * 0.2;
                    const scale = 1 + Math.sin(Date.now() * 0.002) * 0.1;
                    bossAura.scale.set(scale, scale, 1);
                }
            });
        }

        function updateAnimals() {
            animals.forEach(animal => {
                animal.userData.changeDirectionTimer++;

                if (animal.userData.changeDirectionTimer > 100) {
                    animal.userData.direction = new THREE.Vector3(
                        Math.random() - 0.5,
                        0,
                        Math.random() - 0.5
                    ).normalize();
                    animal.userData.changeDirectionTimer = 0;
                }

                animal.position.add(animal.userData.direction.clone().multiplyScalar(animal.userData.speed));

                animal.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.3;

                if (animal.userData.direction.length() > 0) {
                    animal.lookAt(animal.position.clone().add(animal.userData.direction));
                }

                animal.position.x = Math.max(-490, Math.min(490, animal.position.x));
                animal.position.z = Math.max(-490, Math.min(490, animal.position.z));
            });
        }

        function updateHunger() {
            playerStats.hunger -= 0.01;
            playerStats.hunger = Math.max(0, playerStats.hunger);

            if (playerStats.hunger <= 0) {
                playerStats.health -= 0.1;
                playerStats.health = Math.max(0, playerStats.health);
            }

            if (keys['e'] && selectedSlot === 1 && inventory[1].quantity > 0) {
                playerStats.hunger = Math.min(playerStats.maxHunger, playerStats.hunger + 30);
                playerStats.health = Math.min(playerStats.maxHealth, playerStats.health + 20);
                inventory[1].quantity--;
                keys['e'] = false;
                showMessage("Vous avez mang√© de la viande !");
            }

            if (keys['e'] && selectedSlot === 2 && inventory[2].quantity > 0) {
                playerStats.health = Math.min(playerStats.maxHealth, playerStats.health + 50);
                inventory[2].quantity--;
                keys['e'] = false;
                showMessage("Vous avez bu une potion de soin !");
            }
        }

        function updateDayNight() {
            gameTime += 10;
            const hour = Math.floor(gameTime / 1000) % 24;
            const minute = (gameTime / 1000) % 1;

            const sky = world.sky;
            const directionalLight = scene.children.find(child => child instanceof THREE.DirectionalLight);
            const ambientLight = scene.children.find(child => child instanceof THREE.AmbientLight);

            if (sky && directionalLight && ambientLight) {
                let topColor, bottomColor, lightIntensity, ambientIntensity;

                // Aube (5-7h)
                if (hour >= 5 && hour < 7) {
                    const t = (hour - 5 + minute) / 2;
                    topColor = new THREE.Color().lerpColors(
                        new THREE.Color(0x000033),
                        new THREE.Color(0xFF6B35),
                        t
                    );
                    bottomColor = new THREE.Color().lerpColors(
                        new THREE.Color(0x001144),
                        new THREE.Color(0xFFD700),
                        t
                    );
                    lightIntensity = 0.3 + t * 1.2;
                    ambientIntensity = 0.2 + t * 0.3;
                }
                // Jour (7-17h)
                else if (hour >= 7 && hour < 17) {
                    topColor = new THREE.Color(0x0077FF);
                    bottomColor = new THREE.Color(0xFFFFFF);
                    lightIntensity = 1.5;
                    ambientIntensity = 0.5;
                }
                // Cr√©puscule (17-19h)
                else if (hour >= 17 && hour < 19) {
                    const t = (hour - 17 + minute) / 2;
                    topColor = new THREE.Color().lerpColors(
                        new THREE.Color(0x0077FF),
                        new THREE.Color(0xFF6B35),
                        t
                    );
                    bottomColor = new THREE.Color().lerpColors(
                        new THREE.Color(0xFFFFFF),
                        new THREE.Color(0xFF4500),
                        t
                    );
                    lightIntensity = 1.5 - t * 1.2;
                    ambientIntensity = 0.5 - t * 0.3;
                }
                // Nuit (19-5h)
                else {
                    topColor = new THREE.Color(0x000033);
                    bottomColor = new THREE.Color(0x001144);
                    lightIntensity = 0.3;
                    ambientIntensity = 0.2;

                    // √âtoiles la nuit
                    if (!scene.getObjectByName('stars')) {
                        createStars();
                    }
                }

                // Application douce des changements
                if (sky.material.uniforms) {
                    sky.material.uniforms.topColor.value.lerp(topColor, 0.01);
                    sky.material.uniforms.bottomColor.value.lerp(bottomColor, 0.01);
                }
                directionalLight.intensity += (lightIntensity - directionalLight.intensity) * 0.01;
                ambientLight.intensity += (ambientIntensity - ambientLight.intensity) * 0.01;

                // Couleur du brouillard suit le ciel
                if (scene.fog) {
                    const fogColor = new THREE.Color().lerpColors(bottomColor, topColor, 0.5);
                    scene.fog.color.lerp(fogColor, 0.01);
                }
            }
        }

        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 1000;
            const positions = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount * 3; i += 3) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = 450;

                positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i + 1] = radius * Math.cos(phi);
                positions[i + 2] = radius * Math.sin(phi) * Math.sin(theta);
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 2,
                transparent: true,
                opacity: 0.8
            });

            const stars = new THREE.Points(starGeometry, starMaterial);
            stars.name = 'stars';
            scene.add(stars);
        }

        function updateParticles() {
            particles.forEach((particle, index) => {
                if (particle.velocity) {
                    particle.position.add(particle.velocity);
                    particle.velocity.y -= 0.01;
                }

                // Animation de la fum√©e
                if (particle.userData.type === 'smoke') {
                    particle.position.add(particle.userData.velocity);
                    particle.userData.lifetime++;
                    particle.material.opacity = Math.max(0, 0.5 - particle.userData.lifetime * 0.01);
                    particle.scale.set(1 + particle.userData.lifetime * 0.02, 1 + particle.userData.lifetime * 0.02, 1 + particle.userData.lifetime * 0.02);

                    if (particle.userData.lifetime > 50) {
                        scene.remove(particle);
                        particles.splice(index, 1);
                    }
                }
            });

            // Animation des particules ambiantes
            if (particleSystem) {
                const positions = particleSystem.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] += Math.sin(Date.now() * 0.001 + i) * 0.01;
                    positions[i] += Math.cos(Date.now() * 0.001 + i) * 0.005;

                    if (positions[i + 1] > 60) positions[i + 1] = 5;
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.rotation.y += 0.0005;
            }
        }

        function updateTreeWind() {
            const windTime = Date.now() * 0.001;
            trees.forEach(tree => {
                const windPhase = tree.userData.windPhase || 0;
                const leaves = tree.children.filter(child => child.name === 'leaves');
                leaves.forEach(leaf => {
                    leaf.rotation.z = Math.sin(windTime + windPhase) * 0.05;
                    leaf.rotation.x = Math.cos(windTime * 0.7 + windPhase) * 0.03;
                });
            });
        }

        function gameOver() {
            showMessage("GAME OVER - Rechargez la page pour recommencer");
            keys = {};
            touchKeys = {};
        }

        let frameCount = 0;

        function animate() {
            requestAnimationFrame(animate);
            frameCount++;

            if (player) {
                handleMovement();
                updateCamera();
                updateChunks(); // Mise √† jour du syst√®me de chunks
                updateEnemies();
                updateAnimals();
                updateHunger();
                updateDayNight();
                updateParticles();
                updateTreeWind();
                updateUI();

                // Minimap mise √† jour toutes les 10 frames pour optimisation
                if (frameCount % 10 === 0) {
                    updateMinimap();
                }

                // Animation de l'aura du joueur
                const playerAura = player.getObjectByName('playerAura');
                if (playerAura) {
                    playerAura.rotation.z += 0.01;
                    playerAura.material.opacity = 0.2 + Math.sin(Date.now() * 0.002) * 0.15;
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
