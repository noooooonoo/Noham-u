<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flapi Bird â€” Remaster</title>
<style>
  :root{
    --bg-top: #70c5ce;
    --bg-bottom: #9edeff;
    --pipe: #2db23b;
    --pipe-dark: #248f31;
    --ground: #d99a3a;
    --panel: rgba(0,0,0,0.45);
    --accent: #ffd54a;
    --text: #ffffff;
  }
  html,body{height:100%;margin:0;background:linear-gradient(var(--bg-top),var(--bg-bottom));font-family: Inter, "Segoe UI", Roboto, system-ui, Arial; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; display:flex;align-items:center;justify-content:center}
  .container{width:100%;max-width:900px;padding:18px;box-sizing:border-box;display:flex;flex-direction:column;align-items:center;gap:12px}
  .stage{position:relative;display:inline-block;border-radius:10px;overflow:hidden;box-shadow:0 20px 40px rgba(2,10,23,0.25)}
  canvas{display:block;background:transparent;image-rendering:optimizeQuality}
  .ui{
    position:absolute;left:12px;top:12px;right:12px;display:flex;justify-content:space-between;align-items:center;pointer-events:none;
  }
  .score{
    pointer-events:auto;
    background:var(--panel);padding:8px 12px;border-radius:8px;color:var(--text);font-weight:700;letter-spacing:1px;font-size:20px;text-align:center;
    text-shadow:0 1px 0 rgba(0,0,0,0.6);
  }
  .controls{pointer-events:auto;display:flex;gap:8px;align-items:center}
  .btn{
    background:linear-gradient(#ffffff11,#00000008);border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:6px 10px;border-radius:8px;font-weight:600;cursor:pointer;font-size:13px;
    box-shadow:0 2px 6px rgba(0,0,0,0.25);
  }
  .titlePanel{
    position:absolute;left:0;right:0;bottom:18px;display:flex;justify-content:center;pointer-events:none;
  }
  .panelMain{
    pointer-events:auto;
    background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.1));
    color:var(--text);padding:12px 18px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);text-align:center;
    font-weight:600;
  }
  .hint{font-size:13px;opacity:0.9}
  .overlay{
    position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;
  }
  .startBox, .gameOverBox{
    pointer-events:auto;
    background:rgba(0,0,0,0.6);padding:18px;border-radius:12px;color:#fff;text-align:center;
    box-shadow:0 8px 40px rgba(0,0,0,0.6)
  }
  .startBox h1, .gameOverBox h1{margin:0 0 8px 0;font-size:26px;letter-spacing:1px}
  .muted{opacity:0.85;font-weight:500;font-size:13px}
  footer.small{font-size:12px;color:rgba(0,0,0,0.45);margin-top:10px}
  /* fullscreen styles: make canvas fill parent while preserving aspect ratio */
  .fullscreen{position:fixed;left:0;top:0;width:100vw;height:100vh;display:flex;align-items:center;justify-content:center;padding:20px;z-index:9999}
  /* pixel-art look when scaled up */
  .pixelated{image-rendering:crisp-edges;image-rendering:pixelated}
  @media (max-width:520px){
    .container{padding:10px}
    .score{font-size:18px;padding:6px 10px}
  }
</style>
</head>
<body>
<div class="container">
  <div class="stage" id="stage">
    <canvas id="screen" class="pixelated"></canvas>

    <div class="ui" id="ui">
      <div class="score" id="score">0</div>
      <div class="controls">
        <button class="btn" id="fsBtn" title="Plein Ã©cran (double-clic / F)">â›¶</button>
        <button class="btn" id="muteBtn" title="Activer/DÃ©sactiver sons">ðŸ”Š</button>
      </div>
    </div>

    <div class="titlePanel">
      <div class="panelMain" id="panelMain">Flapi Bird â€” Remaster</div>
    </div>

    <!-- Overlay: start & game over sÃ©parÃ©s -->
    <div class="overlay" id="overlay" style="display:flex;">
      <div class="startBox" id="startBox">
        <h1>Flapi Bird</h1>
        <div class="muted">Clique / Tape / Espace pour sauter</div>
        <div style="height:10px"></div>
        <div style="display:flex;gap:8px;justify-content:center">
          <button class="btn" id="startBtn">Jouer</button>
          <button class="btn" id="resetBtn">RÃ©initialiser</button>
        </div>
      </div>

      <div class="gameOverBox" id="gameOverBox" style="display:none;">
        <h1>Game Over</h1>
        <div class="muted" id="gameOverScore">Score: 0 â€” Meilleur: 0</div>
        <div style="height:12px"></div>
        <div style="display:flex;gap:8px;justify-content:center">
          <button class="btn" id="retryBtn">Rejouer</button>
          <button class="btn" id="goStartBtn">Retour au dÃ©part</button>
        </div>
      </div>
    </div>

  </div>
  <footer class="small">Double-clic sur le jeu ou appuyez sur F pour le plein Ã©cran Â· R pour recommencer</footer>
</div>

<script>
(() => {
  const BASE_W = 288, BASE_H = 512;
  const GROUND_H = 112;
  const PIPE_W = 52;
  const PIPE_GAP = 120;
  const PIPE_INTERVAL = 1400;
  const MIN_PIPE_TOP = 48;
  const MAX_PIPE_TOP = BASE_H - GROUND_H - 48 - PIPE_GAP;

  const canvas = document.getElementById('screen');
  const stage = document.getElementById('stage');
  const overlay = document.getElementById('overlay');
  const startBox = document.getElementById('startBox');
  const gameOverBox = document.getElementById('gameOverBox');
  const gameOverScore = document.getElementById('gameOverScore');
  const scoreEl = document.getElementById('score');
  const fsBtn = document.getElementById('fsBtn');
  const muteBtn = document.getElementById('muteBtn');
  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const retryBtn = document.getElementById('retryBtn');
  const goStartBtn = document.getElementById('goStartBtn');
  const ctx = canvas.getContext('2d');

  let devicePixel = Math.max(1, window.devicePixelRatio || 1);
  let cssWidth = 0, cssHeight = 0;

  let state = 'start'; // start, playing, over
  let pipes = [];
  let pipeTimer = 0;
  let lastTs = 0;
  let score = 0;
  let highScore = Number(localStorage.getItem('flapi-high') || 0);
  let muted = false;

  // bird
  const bird = { x: 72, y: BASE_H/2, r: 12, vy: 0, rotation: 0, wing: 0 };
  // when dead we freeze rotation so the bird doesn't snap upright
  let freezeRotation = 0;

  const GRAVITY = 1100;
  const FLAP_V = -290;
  const PIPE_SPEED = -120;

  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = AudioCtx ? new AudioCtx() : null;
  function beep(freq, dur=0.06, type='sine', vol=0.12){
    if(muted || !audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
    o.stop(audioCtx.currentTime + dur + 0.02);
  }

  function resizeCanvas(){
    const isFull = document.fullscreenElement === document.body || document.fullscreenElement === document.documentElement || stage.classList.contains('fullscreen');
    const maxW = isFull ? window.innerWidth - 40 : Math.min(window.innerWidth - 40, 900);
    const maxH = isFull ? window.innerHeight - 40 : window.innerHeight - 140;
    const ratio = BASE_W / BASE_H;
    let w = maxW, h = Math.round(w / ratio);
    if(h > maxH){ h = maxH; w = Math.round(h * ratio); }
    cssWidth = w; cssHeight = h;
    canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
    canvas.width = Math.round(BASE_W * devicePixel);
    canvas.height = Math.round(BASE_H * devicePixel);
    ctx.setTransform(devicePixel,0,0,devicePixel,0,0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  function spawnPipe(){
    const top = Math.floor(rand(MIN_PIPE_TOP, MAX_PIPE_TOP));
    pipes.push({ x: BASE_W + PIPE_W, top: top, bottom: top + PIPE_GAP, passed: false });
  }
  function rand(a,b){ return a + Math.random()*(b-a); }

  function showStartOverlay(){
    overlay.style.display = 'flex';
    startBox.style.display = 'block';
    gameOverBox.style.display = 'none';
  }
  function showGameOverOverlay(){
    overlay.style.display = 'flex';
    startBox.style.display = 'none';
    gameOverBox.style.display = 'block';
    gameOverScore.textContent = `Score: ${score} â€” Meilleur: ${highScore}`;
  }
  function hideOverlay(){
    overlay.style.display = 'none';
    startBox.style.display = 'none';
    gameOverBox.style.display = 'none';
  }

  function resetGame(){
    pipes = []; pipeTimer = 0; score = 0;
    bird.x = 72; bird.y = BASE_H/2; bird.vy = 0; bird.rotation = 0; bird.wing = 0;
    freezeRotation = 0;
    state = 'start';
    scoreEl.textContent = String(score);
    showStartOverlay();
  }

  function doFlap(){
    if(state === 'start'){ state = 'playing'; hideOverlay(); }
    if(state === 'playing'){
      bird.vy = FLAP_V;
      beep(880,0.06,'sine',0.09);
    } else if(state === 'over'){
      // immediate retry
      resetGame();
    }
  }

  function circleRectCollision(cx,cy,r, rx,ry,rw,rh){
    const closestX = clamp(cx, rx, rx + rw);
    const closestY = clamp(cy, ry, ry + rh);
    const dx = cx - closestX, dy = cy - closestY;
    return (dx*dx + dy*dy) < (r*r);
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function draw(){
    const g = ctx.createLinearGradient(0,0,0,BASE_H);
    g.addColorStop(0, '#70c5ce'); g.addColorStop(1, '#9edeff');
    ctx.fillStyle = g; ctx.fillRect(0,0,BASE_W,BASE_H);

    drawHills();

    for(const p of pipes){
      drawPipe(p.x, 0, PIPE_W, p.top);
      drawPipe(p.x, p.bottom, PIPE_W, BASE_H - p.bottom - GROUND_H);
    }

    drawGround();
    drawBird(bird.x, bird.y, bird.r, bird.rotation);
    drawForegroundDecor();

    if(state === 'playing' || state === 'over'){
      ctx.font = 'bold 36px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fillText(String(score), BASE_W/2 + 2, 82 + 2);
      ctx.fillStyle = '#fff'; ctx.fillText(String(score), BASE_W/2, 80);
    }

    // NOTE: removed canvas-drawn Game Over rectangle to avoid overlap with DOM overlay
  }

  function drawHills(){
    ctx.fillStyle = '#4fb3a6';
    ctx.beginPath();
    ctx.ellipse(40, 150, 120, 60, 0, 0, Math.PI*2);
    ctx.ellipse(220, 140, 140, 72, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#66c7b7';
    ctx.beginPath();
    ctx.ellipse(110, 170, 90, 44, 0, 0, Math.PI*2);
    ctx.fill();
  }

  function drawPipe(x,y,w,h){
    if(h <= 0) return;
    ctx.fillStyle = '#2db23b';
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = '#248f31';
    ctx.fillRect(x, y, 6, h);
    ctx.fillStyle = '#248f31';
    ctx.fillRect(x-4, y-8, w+8, 8);
    ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.strokeRect(x, y, w, h);
  }

  function drawGround(){
    const gy = BASE_H - GROUND_H;
    ctx.fillStyle = '#d99a3a'; ctx.fillRect(0, gy, BASE_W, GROUND_H);
    ctx.fillStyle = '#c37a2a';
    for(let i=0;i<BASE_W;i+=20){
      ctx.fillRect(i, gy+6, 10, 8);
    }
    const sg = ctx.createLinearGradient(0, gy, 0, gy+30);
    sg.addColorStop(0, 'rgba(0,0,0,0.12)'); sg.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = sg; ctx.fillRect(0, gy, BASE_W, 18);
  }

  function drawForegroundDecor(){
    ctx.fillStyle = '#2f8a36';
    for(let i=10;i<BASE_W;i+=60){
      ctx.beginPath();
      ctx.moveTo(i, BASE_H - GROUND_H + 8);
      ctx.quadraticCurveTo(i+6, BASE_H - GROUND_H + 2, i+10, BASE_H - GROUND_H + 10);
      ctx.fill();
    }
  }

  function drawBird(x,y,r,rot){
    ctx.save(); ctx.translate(x,y); ctx.rotate(rot);
    ctx.fillStyle = '#ffd54a';
    ctx.beginPath(); ctx.ellipse(0,0,r*1.25,r,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffcf5a';
    const wingY = -2 + Math.sin(bird.wing) * 4;
    ctx.beginPath(); ctx.ellipse(-2, wingY, r*0.7, r*0.35, Math.PI/6, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ff8b3d';
    ctx.beginPath(); ctx.moveTo(r*1, -3); ctx.lineTo(r*1.9, 0); ctx.lineTo(r*1, 6); ctx.closePath(); ctx.fill();
    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-2, -4, r*0.18, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.lineWidth = 1; ctx.stroke();
    ctx.restore();
  }

  function update(dt){
    if(state === 'playing'){
      bird.vy += GRAVITY * dt;
      bird.y += bird.vy * dt;
      bird.rotation = Math.max(-0.8, Math.min(1.2, bird.vy / 600));
      bird.wing += dt * 18;

      for(const p of pipes){
        p.x += PIPE_SPEED * dt;
        if(!p.passed && p.x + PIPE_W < bird.x){
          p.passed = true; score++; updateScore(); beep(1200,0.06,'square',0.08);
          if(score > highScore){ highScore = score; localStorage.setItem('flapi-high', highScore); }
        }
      }
      pipes = pipes.filter(p => p.x + PIPE_W > -20);

      pipeTimer += dt * 1000;
      if(pipeTimer >= PIPE_INTERVAL){
        pipeTimer = 0; spawnPipe();
      }

      for(const p of pipes){
        if(circleRectCollision(bird.x, bird.y, bird.r, p.x, 0, PIPE_W, p.top) ||
           circleRectCollision(bird.x, bird.y, bird.r, p.x, p.bottom, PIPE_W, BASE_H - p.bottom - GROUND_H)){
          // freeze rotation at the instant of death and show overlay
          freezeRotation = bird.rotation;
          state = 'over'; beep(140,0.4,'sawtooth',0.22);
          showGameOverOverlay();
        }
      }

      const groundY = BASE_H - GROUND_H;
      if(bird.y + bird.r >= groundY){
        bird.y = groundY - bird.r;
        // preserve rotation (don't snap upright) and freeze
        freezeRotation = bird.rotation;
        state = 'over'; beep(90,0.6,'sine',0.32); showGameOverOverlay();
      }

      if(bird.y - bird.r <= 0){ bird.y = bird.r; bird.vy = 0; }
    } else if(state === 'start'){
      // only the start screen gets the idle bob animation
      bird.wing += dt * 6;
      bird.rotation = Math.sin(bird.wing) * 0.06;
      bird.y = BASE_H/2 + Math.sin(bird.wing*0.6) * 6;
    } else if(state === 'over'){
      // freeze bird in place: keep the rotation we captured on death and don't change y
      bird.rotation = freezeRotation;
      bird.vy = 0;
      // do not change bird.y or bird.wing so the bird stays where it died
    }
  }

  function updateScore(){ scoreEl.textContent = String(score); }

  let lastFrame = 0;
  function loop(ts){
    if(!lastTs) lastTs = ts;
    const dt = Math.min(0.04, (ts - lastTs)/1000);
    lastTs = ts;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function attachInputs(){
    function startUserAudio(){
      if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    }
    canvas.addEventListener('pointerdown', (e) => { startUserAudio(); doFlap(); });
    window.addEventListener('keydown', (e) => {
      if(e.code === 'Space'){ e.preventDefault(); startUserAudio(); doFlap(); }
      if(e.key === 'r' || e.key === 'R'){ resetGame(); }
      if(e.key === 'f' || e.key === 'F'){ toggleFullscreen(); }
      if(e.key === 'm' || e.key === 'M'){ toggleMute(); }
    });
    canvas.addEventListener('dblclick', toggleFullscreen);
    startBtn.addEventListener('click', () => { doFlap(); });
    resetBtn.addEventListener('click', resetGame);
    fsBtn.addEventListener('click', toggleFullscreen);
    muteBtn.addEventListener('click', toggleMute);
    retryBtn.addEventListener('click', () => { resetGame(); doFlap(); });
    goStartBtn.addEventListener('click', () => { resetGame(); });
    window.addEventListener('touchstart', () => { if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }, {passive:true});
  }
  attachInputs();

  function toggleFullscreen(){
    const isFS = document.fullscreenElement;
    if(!isFS){
      (document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen || document.documentElement.msRequestFullscreen)?.call(document.documentElement);
    } else {
      (document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen)?.call(document);
    }
  }
  document.addEventListener('fullscreenchange', () => {
    const isFS = !!document.fullscreenElement;
    if(isFS){ stage.classList.add('fullscreen'); stage.style.width = '100vw'; stage.style.height = '100vh'; }
    else { stage.classList.remove('fullscreen'); stage.style.width = ''; stage.style.height = ''; }
    setTimeout(resizeCanvas, 60);
  });

  function toggleMute(){
    muted = !muted; muteBtn.textContent = muted ? 'ðŸ”ˆ' : 'ðŸ”Š';
  }
  muteBtn.textContent = muted ? 'ðŸ”ˆ' : 'ðŸ”Š';

  spawnPipe();
  updateScore();
  showStartOverlay();

  window.flapiReset = resetGame;
  function ensurePixelated(){ canvas.classList.add('pixelated'); }
  ensurePixelated();

})();
</script>
</body>
</html>
