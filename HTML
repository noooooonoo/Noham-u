

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG 3D - Terres d'Aventure</title>
    <style>
        .touch-btn {
            width: 48px;
            height: 48px;
            background: rgba(50,50,50,0.8);
            color: #FFD700;
            font-size: 30px;
            border: 2px solid #FFD700;
            border-radius: 16px;
            margin: 3px;
            cursor: pointer;
            touch-action: manipulation;
        }
        .touch-btn:active {
            background: #FFD700;
            color: #333;
        }
        .cinematic {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, rgba(10,10,30,0.97), rgba(40,20,60,0.97));
            color: #FFD700;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            z-index: 100;
            text-align: center;
            padding: 20px;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: white;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            user-select: none;
        }

        .health-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 250px;
            height: 30px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #gold;
            border-radius: 15px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6b6b);
            transition: width 0.3s;
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
        }

        .hunger-bar {
            position: absolute;
            top: 60px;
            left: 20px;
            width: 250px;
            height: 30px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #8B4513;
            border-radius: 15px;
            overflow: hidden;
        }

        .hunger-fill {
            height: 100%;
            background: linear-gradient(90deg, #8B4513, #D2691E);
            transition: width 0.3s;
            box-shadow: 0 0 20px rgba(139,69,19,0.5);
        }

        .experience-bar {
            position: absolute;
            top: 100px;
            left: 20px;
            width: 250px;
            height: 30px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #FFD700;
            border-radius: 15px;
            overflow: hidden;
        }

        .experience-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            transition: width 0.3s;
            box-shadow: 0 0 20px rgba(255,215,0,0.5);
        }

        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #FFD700;
            font-size: 14px;
        }

        .inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #FFD700;
            pointer-events: all;
        }

        .inventory-slot {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.1);
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .inventory-slot:hover {
            background: rgba(255,255,255,0.2);
            border-color: #FFD700;
            transform: scale(1.1);
        }

        .inventory-slot.selected {
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0,255,0,0.5);
        }

        .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: #FFD700;
            color: #000;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        }

        .quest-log {
            position: absolute;
            top: 150px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #9370DB;
            max-width: 300px;
        }

        .quest-title {
            color: #FFD700;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .controls {
            position: absolute;
            bottom: 100px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4169E1;
            font-size: 12px;
        }

        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 20px 40px;
            border-radius: 10px;
            border: 2px solid #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            display: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        .minimap {
            position: absolute;
            top: 20px;
            right: 320px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #00CED1;
            border-radius: 10px;
            overflow: hidden;
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
        }

        .dialog-box {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(30,30,30,0.95));
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #FFD700;
            max-width: 600px;
            display: none;
            pointer-events: all;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        .dialog-speaker {
            color: #FFD700;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .dialog-text {
            font-size: 16px;
            line-height: 1.5;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            color: #FFD700;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Chargement du monde...</div>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div class="health-bar">
            <div class="health-fill" id="healthFill" style="width: 100%"></div>
        </div>
        <div class="hunger-bar">
            <div class="hunger-fill" id="hungerFill" style="width: 100%"></div>
        </div>
        <div class="experience-bar">
            <div class="experience-fill" id="experienceFill" style="width: 0%"></div>
        </div>

        <div class="stats">
            <div>Niveau: <span id="level">1</span></div>
            <div>Or: <span id="gold">0</span></div>
            <div>Position: <span id="position">0, 0</span></div>
            <div>Temps: <span id="gameTime">Jour</span></div>
        </div>

        <div class="quest-log">
            <div class="quest-title">Qu√™te Active:</div>
            <div id="questText">Trouve l'√©p√©e dans la maison de d√©part</div>
        </div>

        <div class="controls">
            <div><strong>Contr√¥les:</strong></div>
            <div>ZQSD/WASD - Se d√©placer</div>
            <div>Fl√®ches ‚Üê‚Üí‚Üë‚Üì - Cam√©ra</div>
            <div>Clic gauche - Attaquer/Interagir</div>
            <div>Espace - Sauter</div>
            <div>E - Ramasser/Parler/Entrer</div>
            <div>1-5 - S√©lectionner objet</div>
        </div>

        <div class="minimap">
            <canvas id="minimapCanvas"></canvas>
        </div>

        <div class="inventory">
            <div class="inventory-slot selected" data-slot="0">‚ùå</div>
            <div class="inventory-slot" data-slot="1">üçñ<span class="item-count">5</span></div>
            <div class="inventory-slot" data-slot="2">üß™<span class="item-count">3</span></div>
            <div class="inventory-slot" data-slot="3">ü™ô<span class="item-count">10</span></div>
            <div class="inventory-slot" data-slot="4">üìú</div>
        </div>

        <div class="dialog-box" id="dialogBox">
            <div class="dialog-speaker" id="dialogSpeaker">Villageois</div>
            <div class="dialog-text" id="dialogText"></div>
        </div>

        <div class="message" id="message"></div>
    </div>

    <div class="cinematic" id="cinematic">
        <div style="font-size: 2.5rem; margin-bottom: 30px;">üè∞ Les Terres d'Aventure üè∞</div>
        <div style="margin: 20px 0;">Il √©tait une fois‚Ä¶</div>
        <div style="margin: 20px 0;">Un monde envahi par les monstres‚Ä¶</div>
        <div style="margin: 20px 0;">R√©veill√© dans une maison √©trange, tu dois trouver ton √©p√©e et sauver le village !</div>
        <button class="touch-btn" style="margin-top:40px; width: auto; padding: 15px 30px;" onclick="endCinematic()">‚öîÔ∏è Commencer l'Aventure</button>
    </div>

    <div id="touchControls" style="display:none; position:absolute;bottom:20px;left:0;right:0;z-index:10;pointer-events:none;">
        <!-- Joystick virtuel gauche pour d√©placement -->
        <div id="joystickLeft" style="position:absolute;bottom:20px;left:20px;width:120px;height:120px;background:rgba(50,50,50,0.5);border:3px solid #FFD700;border-radius:50%;pointer-events:all;">
            <div id="joystickKnobLeft" style="position:absolute;width:50px;height:50px;background:#FFD700;border-radius:50%;top:50%;left:50%;transform:translate(-50%,-50%);"></div>
        </div>

        <!-- Joystick virtuel droite pour cam√©ra -->
        <div id="joystickRight" style="position:absolute;bottom:20px;right:20px;width:120px;height:120px;background:rgba(50,50,50,0.5);border:3px solid #FFD700;border-radius:50%;pointer-events:all;">
            <div id="joystickKnobRight" style="position:absolute;width:50px;height:50px;background:#FFD700;border-radius:50%;top:50%;left:50%;transform:translate(-50%,-50%);"></div>
        </div>

        <!-- Boutons d'action -->
        <div style="position:absolute;bottom:160px;right:20px;display:flex;flex-direction:column;gap:10px;pointer-events:all;">
            <button class="touch-btn" id="btnJump" style="width:60px;height:60px;font-size:24px;">‚è´</button>
            <button class="touch-btn" id="btnAction" style="width:60px;height:60px;font-size:24px;">‚öîÔ∏è</button>
            <button class="touch-btn" id="btnInteract" style="width:60px;height:60px;font-size:24px;">üó®Ô∏è</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variables globales du jeu
        let scene, camera, renderer;
        let player, playerMesh;
        let world = {};
        let enemies = [];
        let npcs = [];
        let items = [];
        let particles = [];
        let buildings = [];
        let trees = [];
        let chests = [];
        let animals = [];
        let indoorMode = false;
        let currentBuilding = null;

        // √âtat du joueur
        let playerStats = {
            health: 100,
            maxHealth: 100,
            hunger: 100,
            maxHunger: 100,
            experience: 0,
            level: 1,
            gold: 0,
            damage: 10,
            defense: 5,
            speed: 0.15,
            jumpPower: 0.3,
            hasSword: false
        };

        // Inventaire
        let inventory = [
            { type: 'empty', name: 'Vide', icon: '‚ùå', quantity: 0 },
            { type: 'food', name: 'Viande', icon: 'üçñ', heal: 20, hunger: 30, quantity: 5 },
            { type: 'potion', name: 'Potion', icon: 'üß™', heal: 50, quantity: 3 },
            { type: 'gold', name: 'Pi√®ces', icon: 'ü™ô', quantity: 10 },
            { type: 'quest', name: 'Parchemin', icon: 'üìú', quantity: 1 }
        ];
        let selectedSlot = 0;

        // Contr√¥les
        let keys = {};
        let touchKeys = {};
        let mouseX = 0, mouseY = 0;
        let isPointerLocked = false;
        let velocity = new THREE.Vector3();
        let canJump = true;

        // Joysticks virtuels
        let joystickLeftActive = false;
        let joystickRightActive = false;
        let joystickLeftVector = { x: 0, y: 0 };
        let joystickRightVector = { x: 0, y: 0 };

        // Animation du personnage
        let walkAnimationTime = 0;
        let isPlayerMoving = false;

        // Temps de jeu
        let gameTime = 0;
        let dayNightCycle = true;

        // √ânigmes et qu√™tes
        let dungeonPuzzleSolved = false;
        let startHousePosition = { x: 0, y: 0, z: 0 };

        function endCinematic() {
            document.getElementById('cinematic').style.display = 'none';
        }

        // Initialisation du jeu
        function init() {
            // Sc√®ne
            scene = new THREE.Scene();

            // Cam√©ra
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lumi√®res
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Cr√©er le monde
            createWorld();
            createPlayer();

            // Cr√©er la maison de d√©part avec l'√©p√©e
            startHousePosition = createStartHouse(0, 0, 0);

            // Placer le joueur dans la maison de d√©part
            player.position.set(startHousePosition.x, 2, startHousePosition.z);

            createVillage(50, 0, 50);
            createDungeon(-100, 0, -100);
            createDungeon(150, 0, 150);
            createDungeon(-150, 0, 150);
            createDungeon(100, 0, -150);
            createForest();
            spawnEnemies();
            spawnChests();
            spawnAnimals();

            // √âv√©nements
            setupControls();
            setupTouchControls();

            // Masquer l'√©cran de chargement
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 1000);

            // Lancer la boucle de jeu
            animate();
        }

        function createWorld() {
            const terrainGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
            const terrainMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00FF00,
                wireframe: false
            });

            const vertices = terrainGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.sin(vertices[i] * 0.05) * Math.cos(vertices[i + 1] * 0.05) * 3;
            }
            terrainGeometry.computeVertexNormals();

            const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            scene.add(terrain);
            world.terrain = terrain;

            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
        }

        function createPlayer() {
            const playerGroup = new THREE.Group();

            const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.5);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            playerGroup.add(body);

            const headGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBBB });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.2;
            head.castShadow = true;
            playerGroup.add(head);

            const armGeometry = new THREE.BoxGeometry(0.3, 1, 0.3);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBBB });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.7, 1, 0);
            leftArm.castShadow = true;
            playerGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.7, 1, 0);
            rightArm.castShadow = true;
            playerGroup.add(rightArm);

            const legGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.3, 0, 0);
            leftLeg.castShadow = true;
            playerGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.3, 0, 0);
            rightLeg.castShadow = true;
            playerGroup.add(rightLeg);

            playerGroup.position.set(0, 2, 0);
            scene.add(playerGroup);
            player = playerGroup;
            playerMesh = playerGroup;
        }

        function createStartHouse(x, y, z) {
            const house = new THREE.Group();

            const wallGeometry = new THREE.BoxGeometry(12, 6, 12);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            walls.position.y = 3;
            walls.castShadow = true;
            walls.receiveShadow = true;
            house.add(walls);

            const roofGeometry = new THREE.ConeGeometry(8, 4, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x8B0000 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 8;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            house.add(roof);

            const doorGeometry = new THREE.BoxGeometry(2, 4, 0.2);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x4B3621 });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 2, 6);
            house.add(door);

            house.position.set(x, y, z);
            house.userData = { 
                type: 'start_house',
                interior: { x: x, y: y, z: z },
                hasInterior: true
            };
            scene.add(house);
            buildings.push(house);

            createSwordItem(x, y + 1.5, z);

            return { x: x, y: y, z: z };
        }

        function createSwordItem(x, y, z) {
            const swordGroup = new THREE.Group();

            const swordGeometry = new THREE.BoxGeometry(0.2, 2, 0.3);
            const swordMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
            const sword = new THREE.Mesh(swordGeometry, swordMaterial);
            sword.castShadow = true;
            swordGroup.add(sword);

            const handleGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.5, 8);
            const handleMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.y = -1;
            swordGroup.add(handle);

            swordGroup.position.set(x, y, z);
            swordGroup.rotation.z = Math.PI / 4;
            swordGroup.userData = { type: 'sword_item', name: '√âp√©e l√©gendaire' };
            scene.add(swordGroup);
            items.push(swordGroup);
        }

        function spawnAnimals() {
            for (let i = 0; i < 15; i++) {
                const x = (Math.random() - 0.5) * 400;
                const z = (Math.random() - 0.5) * 400;
                createRabbit(x, 0, z);
            }
        }

        function createRabbit(x, y, z) {
            const rabbit = new THREE.Group();

            const bodyGeometry = new THREE.SphereGeometry(0.5, 8, 6);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            rabbit.add(body);

            const headGeometry = new THREE.SphereGeometry(0.3, 8, 6);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.set(0, 0.8, 0.3);
            head.castShadow = true;
            rabbit.add(head);

            const earGeometry = new THREE.ConeGeometry(0.1, 0.5, 6);
            const leftEar = new THREE.Mesh(earGeometry, bodyMaterial);
            leftEar.position.set(-0.15, 1.2, 0.3);
            rabbit.add(leftEar);

            const rightEar = new THREE.Mesh(earGeometry, bodyMaterial);
            rightEar.position.set(0.15, 1.2, 0.3);
            rabbit.add(rightEar);

            rabbit.position.set(x, y, z);
            rabbit.userData = {
                type: 'animal',
                speed: 0.02,
                direction: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
                changeDirectionTimer: 0
            };
            scene.add(rabbit);
            animals.push(rabbit);
        }

        function createVillage(x, y, z) {
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 5; j++) {
                    if (Math.random() > 0.3) {
                        const houseX = x + i * 15 - 30;
                        const houseZ = z + j * 15 - 30;
                        createHouse(houseX, y, houseZ);

                        if (Math.random() > 0.5) {
                            createNPC(houseX + 5, y, houseZ + 5, 'Villageois', 0x8B4513);
                        }
                    }
                }
            }

            const plazaGeometry = new THREE.CircleGeometry(20, 32);
            const plazaMaterial = new THREE.MeshLambertMaterial({ color: 0xD2691E });
            const plaza = new THREE.Mesh(plazaGeometry, plazaMaterial);
            plaza.rotation.x = -Math.PI / 2;
            plaza.position.set(x, y + 0.1, z);
            plaza.receiveShadow = true;
            scene.add(plaza);

            const fountainBase = new THREE.CylinderGeometry(5, 6, 1, 16);
            const fountainMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            const fountain = new THREE.Mesh(fountainBase, fountainMaterial);
            fountain.position.set(x, y + 0.5, z);
            fountain.castShadow = true;
            scene.add(fountain);

            const waterGeometry = new THREE.CylinderGeometry(4.5, 4.5, 0.5, 16);
            const waterMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x006994,
                transparent: true,
                opacity: 0.8
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.position.set(x, y + 1, z);
            scene.add(water);
        }

        function createHouse(x, y, z) {
            const house = new THREE.Group();

            const wallGeometry = new THREE.BoxGeometry(8, 6, 8);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            walls.position.y = 3;
            walls.castShadow = true;
            walls.receiveShadow = true;
            house.add(walls);

            const roofGeometry = new THREE.ConeGeometry(6, 4, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x8B0000 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 8;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            house.add(roof);

            const doorGeometry = new THREE.BoxGeometry(2, 4, 0.2);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 2, 4);
            house.add(door);

            const windowGeometry = new THREE.BoxGeometry(1.5, 1.5, 0.2);
            const windowMaterial = new THREE.MeshLambertMaterial({ color: 0x87CEEB });

            const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
            window1.position.set(2.5, 3, 4);
            house.add(window1);

            const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
            window2.position.set(-2.5, 3, 4);
            house.add(window2);

            house.position.set(x, y, z);
            house.userData = { 
                type: 'house',
                interior: { x: x, y: y + 1, z: z },
                hasInterior: true
            };
            scene.add(house);
            buildings.push(house);

            createInteriorDecoration(x, y, z);
        }

        function createInteriorDecoration(houseX, houseY, houseZ) {
            for (let i = 0; i < 3; i++) {
                const potX = houseX + (Math.random() - 0.5) * 6;
                const potZ = houseZ + (Math.random() - 0.5) * 6;
                createPot(potX, houseY + 0.5, potZ);
            }
        }

        function createPot(x, y, z) {
            const potGeometry = new THREE.CylinderGeometry(0.3, 0.4, 0.8, 8);
            const potMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const pot = new THREE.Mesh(potGeometry, potMaterial);
            pot.position.set(x, y, z);
            pot.castShadow = true;
            pot.userData = { type: 'decoration' };
            scene.add(pot);
        }

        function createDungeon(x, y, z) {
            const entranceGeometry = new THREE.BoxGeometry(12, 10, 3);
            const entranceMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
            const entrance = new THREE.Mesh(entranceGeometry, entranceMaterial);
            entrance.position.set(x, y + 5, z);
            entrance.castShadow = true;
            scene.add(entrance);

            const doorGeometry = new THREE.BoxGeometry(4, 6, 0.5);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(x, y + 3, z + 1.5);
            door.castShadow = true;
            door.userData = { 
                type: 'dungeon_door',
                interior: { x: x, y: y + 1, z: z + 20 },
                hasInterior: true
            };
            scene.add(door);
            buildings.push(door);

            const textGeometry = new THREE.PlaneGeometry(5, 1);
            const textMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
            const textSign = new THREE.Mesh(textGeometry, textMaterial);
            textSign.position.set(x, y + 7, z + 2);
            scene.add(textSign);

            for (let i = -1; i <= 1; i += 2) {
                const torchBase = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
                const torchMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const torch = new THREE.Mesh(torchBase, torchMaterial);
                torch.position.set(x + i * 4, y + 4, z + 1.5);
                scene.add(torch);

                const flameGeometry = new THREE.SphereGeometry(0.4, 8, 8);
                const flameMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFFA500
                });
                const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                flame.position.set(x + i * 4, y + 6, z + 1.5);
                scene.add(flame);

                const torchLight = new THREE.PointLight(0xFFA500, 2, 15);
                torchLight.position.copy(flame.position);
                scene.add(torchLight);
            }

            const skullGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const skullMaterial = new THREE.MeshLambertMaterial({ color: 0xEEEEEE });
            const skull = new THREE.Mesh(skullGeometry, skullMaterial);
            skull.position.set(x, y + 1, z + 3);
            skull.castShadow = true;
            scene.add(skull);
        }

        function createDungeonInterior(x, y, z) {
            // SALLE 1 - Entr√©e avec √©nigme
            const room1Floor = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 20),
                new THREE.MeshLambertMaterial({ color: 0x2F4F4F })
            );
            room1Floor.rotation.x = -Math.PI / 2;
            room1Floor.position.set(x, y, z + 10);
            room1Floor.receiveShadow = true;
            room1Floor.userData = { type: 'interior' };
            scene.add(room1Floor);

            // Murs salle 1
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            
            const wall1Left = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            wall1Left.position.set(x - 15, y + 5, z + 10);
            wall1Left.rotation.y = Math.PI / 2;
            wall1Left.receiveShadow = true;
            wall1Left.userData = { type: 'interior' };
            scene.add(wall1Left);

            const wall1Right = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            wall1Right.position.set(x + 15, y + 5, z + 10);
            wall1Right.rotation.y = -Math.PI / 2;
            wall1Right.receiveShadow = true;
            wall1Right.userData = { type: 'interior' };
            scene.add(wall1Right);

            const wall1Back = new THREE.Mesh(new THREE.PlaneGeometry(30, 10), wallMaterial);
            wall1Back.position.set(x, y + 5, z);
            wall1Back.receiveShadow = true;
            wall1Back.userData = { type: 'interior' };
            scene.add(wall1Back);

            // √ânigme salle 1
            createPuzzle(x, y, z + 5);
            
            // Mini-boss salle 1
            createEnemy(x - 8, y + 1, z + 10, 'goblin');
            createEnemy(x + 8, y + 1, z + 10, 'goblin');

            // Coffre salle 1
            createChest(x - 10, y, z + 15);

            // COULOIR 1
            const corridor1Floor = new THREE.Mesh(
                new THREE.PlaneGeometry(8, 15),
                new THREE.MeshLambertMaterial({ color: 0x2F4F4F })
            );
            corridor1Floor.rotation.x = -Math.PI / 2;
            corridor1Floor.position.set(x, y, z + 27);
            corridor1Floor.receiveShadow = true;
            corridor1Floor.userData = { type: 'interior' };
            scene.add(corridor1Floor);

            const corridor1Left = new THREE.Mesh(new THREE.PlaneGeometry(15, 10), wallMaterial);
            corridor1Left.position.set(x - 4, y + 5, z + 27);
            corridor1Left.rotation.y = Math.PI / 2;
            corridor1Left.receiveShadow = true;
            corridor1Left.userData = { type: 'interior' };
            scene.add(corridor1Left);

            const corridor1Right = new THREE.Mesh(new THREE.PlaneGeometry(15, 10), wallMaterial);
            corridor1Right.position.set(x + 4, y + 5, z + 27);
            corridor1Right.rotation.y = -Math.PI / 2;
            corridor1Right.receiveShadow = true;
            corridor1Right.userData = { type: 'interior' };
            scene.add(corridor1Right);

            // Mini-boss dans le couloir
            createEnemy(x, y + 1, z + 27, 'slime');
            createEnemy(x + 2, y + 1, z + 30, 'slime');

            // SALLE 2 - Salle des tr√©sors
            const room2Floor = new THREE.Mesh(
                new THREE.PlaneGeometry(25, 20),
                new THREE.MeshLambertMaterial({ color: 0x2F4F4F })
            );
            room2Floor.rotation.x = -Math.PI / 2;
            room2Floor.position.set(x, y, z + 45);
            room2Floor.receiveShadow = true;
            room2Floor.userData = { type: 'interior' };
            scene.add(room2Floor);

            const wall2Left = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            wall2Left.position.set(x - 12.5, y + 5, z + 45);
            wall2Left.rotation.y = Math.PI / 2;
            wall2Left.receiveShadow = true;
            wall2Left.userData = { type: 'interior' };
            scene.add(wall2Left);

            const wall2Right = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            wall2Right.position.set(x + 12.5, y + 5, z + 45);
            wall2Right.rotation.y = -Math.PI / 2;
            wall2Right.receiveShadow = true;
            wall2Right.userData = { type: 'interior' };
            scene.add(wall2Right);

            // Coffres et mini-boss salle 2
            createChest(x - 8, y, z + 42);
            createChest(x + 8, y, z + 42);
            createChest(x, y, z + 48);
            createEnemy(x - 6, y + 1, z + 45, 'goblin');
            createEnemy(x + 6, y + 1, z + 45, 'goblin');

            // COULOIR 2
            const corridor2Floor = new THREE.Mesh(
                new THREE.PlaneGeometry(8, 15),
                new THREE.MeshLambertMaterial({ color: 0x2F4F4F })
            );
            corridor2Floor.rotation.x = -Math.PI / 2;
            corridor2Floor.position.set(x, y, z + 62);
            corridor2Floor.receiveShadow = true;
            corridor2Floor.userData = { type: 'interior' };
            scene.add(corridor2Floor);

            const corridor2Left = new THREE.Mesh(new THREE.PlaneGeometry(15, 10), wallMaterial);
            corridor2Left.position.set(x - 4, y + 5, z + 62);
            corridor2Left.rotation.y = Math.PI / 2;
            corridor2Left.receiveShadow = true;
            corridor2Left.userData = { type: 'interior' };
            scene.add(corridor2Left);

            const corridor2Right = new THREE.Mesh(new THREE.PlaneGeometry(15, 10), wallMaterial);
            corridor2Right.position.set(x + 4, y + 5, z + 62);
            corridor2Right.rotation.y = -Math.PI / 2;
            corridor2Right.receiveShadow = true;
            corridor2Right.userData = { type: 'interior' };
            scene.add(corridor2Right);

            // SALLE DU BOSS FINAL
            const bossFloor = new THREE.Mesh(
                new THREE.PlaneGeometry(35, 30),
                new THREE.MeshLambertMaterial({ color: 0x1a1a1a })
            );
            bossFloor.rotation.x = -Math.PI / 2;
            bossFloor.position.set(x, y, z + 85);
            bossFloor.receiveShadow = true;
            bossFloor.userData = { type: 'interior' };
            scene.add(bossFloor);

            const wallBossLeft = new THREE.Mesh(new THREE.PlaneGeometry(30, 12), wallMaterial);
            wallBossLeft.position.set(x - 17.5, y + 6, z + 85);
            wallBossLeft.rotation.y = Math.PI / 2;
            wallBossLeft.receiveShadow = true;
            wallBossLeft.userData = { type: 'interior' };
            scene.add(wallBossLeft);

            const wallBossRight = new THREE.Mesh(new THREE.PlaneGeometry(30, 12), wallMaterial);
            wallBossRight.position.set(x + 17.5, y + 6, z + 85);
            wallBossRight.rotation.y = -Math.PI / 2;
            wallBossRight.receiveShadow = true;
            wallBossRight.userData = { type: 'interior' };
            scene.add(wallBossRight);

            const wallBossBack = new THREE.Mesh(new THREE.PlaneGeometry(35, 12), wallMaterial);
            wallBossBack.position.set(x, y + 6, z + 100);
            wallBossBack.rotation.y = Math.PI;
            wallBossBack.receiveShadow = true;
            wallBossBack.userData = { type: 'interior' };
            scene.add(wallBossBack);

            // Boss final
            createEnemy(x, y + 1, z + 90, 'boss');

            // Coffres finaux
            createChest(x - 12, y, z + 95);
            createChest(x + 12, y, z + 95);

            // Plafond global
            const ceilingMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const ceiling1 = new THREE.Mesh(new THREE.PlaneGeometry(30, 20), ceilingMaterial);
            ceiling1.rotation.x = Math.PI / 2;
            ceiling1.position.set(x, y + 10, z + 10);
            ceiling1.userData = { type: 'interior' };
            scene.add(ceiling1);

            const ceiling2 = new THREE.Mesh(new THREE.PlaneGeometry(8, 15), ceilingMaterial);
            ceiling2.rotation.x = Math.PI / 2;
            ceiling2.position.set(x, y + 10, z + 27);
            ceiling2.userData = { type: 'interior' };
            scene.add(ceiling2);

            const ceiling3 = new THREE.Mesh(new THREE.PlaneGeometry(25, 20), ceilingMaterial);
            ceiling3.rotation.x = Math.PI / 2;
            ceiling3.position.set(x, y + 10, z + 45);
            ceiling3.userData = { type: 'interior' };
            scene.add(ceiling3);

            const ceiling4 = new THREE.Mesh(new THREE.PlaneGeometry(8, 15), ceilingMaterial);
            ceiling4.rotation.x = Math.PI / 2;
            ceiling4.position.set(x, y + 10, z + 62);
            ceiling4.userData = { type: 'interior' };
            scene.add(ceiling4);

            const ceiling5 = new THREE.Mesh(new THREE.PlaneGeometry(35, 30), ceilingMaterial);
            ceiling5.rotation.x = Math.PI / 2;
            ceiling5.position.set(x, y + 12, z + 85);
            ceiling5.userData = { type: 'interior' };
            scene.add(ceiling5);

            // Torches murales partout
            const torchPositions = [
                { x: x - 12, z: z + 5 }, { x: x + 12, z: z + 5 },
                { x: x - 12, z: z + 15 }, { x: x + 12, z: z + 15 },
                { x: x - 10, z: z + 42 }, { x: x + 10, z: z + 42 },
                { x: x - 10, z: z + 48 }, { x: x + 10, z: z + 48 },
                { x: x - 14, z: z + 80 }, { x: x + 14, z: z + 80 },
                { x: x - 14, z: z + 90 }, { x: x + 14, z: z + 90 }
            ];

            torchPositions.forEach(pos => {
                const torchLight = new THREE.PointLight(0xFFA500, 1.5, 12);
                torchLight.position.set(pos.x, y + 5, pos.z);
                torchLight.castShadow = true;
                torchLight.userData = { type: 'interior' };
                scene.add(torchLight);

                const flame = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xFFA500 })
                );
                flame.position.set(pos.x, y + 5, pos.z);
                flame.userData = { type: 'interior' };
                scene.add(flame);
            });
        }

        function createPuzzle(x, y, z) {
            const leverPositions = [
                { x: x - 5, z: z + 5, order: 1, color: 0xFF0000 },
                { x: x + 5, z: z + 5, order: 2, color: 0x00FF00 },
                { x: x - 5, z: z + 15, order: 3, color: 0x0000FF },
                { x: x + 5, z: z + 15, order: 4, color: 0xFFFF00 }
            ];

            leverPositions.forEach(pos => {
                const leverBase = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
                const leverMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const base = new THREE.Mesh(leverBase, leverMaterial);
                base.position.set(pos.x, y + 1, pos.z);
                base.userData = { type: 'interior' };
                scene.add(base);

                const leverHandle = new THREE.BoxGeometry(0.2, 1, 0.2);
                const handleMaterial = new THREE.MeshLambertMaterial({ color: pos.color });
                const handle = new THREE.Mesh(leverHandle, handleMaterial);
                handle.position.set(pos.x, y + 2.5, pos.z);
                handle.castShadow = true;
                handle.userData = {
                    type: 'puzzle_lever',
                    order: pos.order,
                    activated: false
                };
                scene.add(handle);
                items.push(handle);
            });
        }

        function createForest() {
            for (let i = 0; i < 100; i++) {
                const x = (Math.random() - 0.5) * 400;
                const z = (Math.random() - 0.5) * 400;

                if (Math.abs(x) > 20 || Math.abs(z) > 20) {
                    if (Math.abs(x - 50) > 40 || Math.abs(z - 50) > 40) {
                        createTree(x, 0, z);
                    }
                }
            }
        }

        function createTree(x, y, z) {
            const tree = new THREE.Group();

            const trunkGeometry = new THREE.CylinderGeometry(1, 1.5, 8, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 4;
            trunk.castShadow = true;
            tree.add(trunk);

            const leavesGeometry = new THREE.SphereGeometry(4, 8, 6);
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 9;
            leaves.castShadow = true;
            tree.add(leaves);

            tree.position.set(x, y, z);
            scene.add(tree);
            trees.push(tree);
        }

        function createNPC(x, y, z, name, color) {
            const npcGroup = new THREE.Group();

            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.4);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.8;
            body.castShadow = true;
            npcGroup.add(body);

            const headGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBBB });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.8;
            head.castShadow = true;
            npcGroup.add(head);

            npcGroup.position.set(x, y + 1, z);
            npcGroup.userData = { 
                type: 'npc', 
                name: name,
                dialog: [
                    "Bienvenue dans notre village, brave aventurier !",
                    "Les monstres deviennent plus nombreux ces derniers temps...",
                    "Le donjon au nord renferme de grands tr√©sors, mais aussi de terribles dangers !",
                    "N'oublie pas de te nourrir r√©guli√®rement pour garder tes forces."
                ]
            };

            scene.add(npcGroup);
            npcs.push(npcGroup);
        }

        function spawnEnemies() {
            for (let i = 0; i < 20; i++) {
                const x = (Math.random() - 0.5) * 300;
                const z = (Math.random() - 0.5) * 300;

                if (Math.abs(x) > 30 || Math.abs(z) > 30) {
                    createEnemy(x, 1, z, Math.random() > 0.7 ? 'goblin' : 'slime');
                }
            }
        }

        function createEnemy(x, y, z, type) {
            const enemy = new THREE.Group();

            if (type === 'slime') {
                const slimeGeometry = new THREE.SphereGeometry(0.8, 8, 6);
                const slimeMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x00FF00,
                    transparent: true,
                    opacity: 0.8
                });
                const slimeBody = new THREE.Mesh(slimeGeometry, slimeMaterial);
                slimeBody.castShadow = true;
                enemy.add(slimeBody);

                enemy.userData = {
                    type: 'enemy',
                    enemyType: 'slime',
                    health: 30,
                    maxHealth: 30,
                    damage: 5,
                    speed: 0.02,
                    experience: 10,
                    gold: 5
                };
            } else if (type === 'goblin') {
                const bodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.3);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4B8B3B });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.5;
                body.castShadow = true;
                enemy.add(body);

                const headGeometry = new THREE.SphereGeometry(0.3, 6, 6);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0x4B8B3B });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.2;
                head.castShadow = true;
                enemy.add(head);

                enemy.userData = {
                    type: 'enemy',
                    enemyType: 'goblin',
                    health: 50,
                    maxHealth: 50,
                    damage: 10,
                    speed: 0.05,
                    experience: 20,
                    gold: 15
                };
            } else if (type === 'boss') {
                const bodyGeometry = new THREE.BoxGeometry(2, 3, 1);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B0000 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.5;
                body.castShadow = true;
                enemy.add(body);

                const headGeometry = new THREE.SphereGeometry(0.8, 8, 8);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0x8B0000 });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 3.5;
                head.castShadow = true;
                enemy.add(head);

                const hornGeometry = new THREE.ConeGeometry(0.2, 1, 4);
                const hornMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const leftHorn = new THREE.Mesh(hornGeometry, hornMaterial);
                leftHorn.position.set(-0.4, 4.2, 0);
                leftHorn.rotation.z = -0.3;
                enemy.add(leftHorn);

                const rightHorn = new THREE.Mesh(hornGeometry, hornMaterial);
                rightHorn.position.set(0.4, 4.2, 0);
                rightHorn.rotation.z = 0.3;
                enemy.add(rightHorn);

                enemy.userData = {
                    type: 'enemy',
                    enemyType: 'boss',
                    health: 200,
                    maxHealth: 200,
                    damage: 25,
                    speed: 0.03,
                    experience: 100,
                    gold: 100
                };
            }

            enemy.position.set(x, y, z);
            scene.add(enemy);
            enemies.push(enemy);

            const healthBarGeometry = new THREE.PlaneGeometry(1, 0.1);
            const healthBarMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
            const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
            healthBar.position.y = 2.5;
            enemy.add(healthBar);
            enemy.userData.healthBar = healthBar;
        }

        function spawnChests() {
            for (let i = 0; i < 10; i++) {
                const x = (Math.random() - 0.5) * 400;
                const z = (Math.random() - 0.5) * 400;
                createChest(x, 0, z);
            }
        }

        function createChest(x, y, z) {
            const chest = new THREE.Group();

            const baseGeometry = new THREE.BoxGeometry(2, 1.5, 1.5);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.75;
            base.castShadow = true;
            chest.add(base);

            const lidGeometry = new THREE.BoxGeometry(2, 0.5, 1.5);
            const lidMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const lid = new THREE.Mesh(lidGeometry, lidMaterial);
            lid.position.y = 1.75;
            lid.castShadow = true;
            chest.add(lid);

            const lockGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.1);
            const lockMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const lock = new THREE.Mesh(lockGeometry, lockMaterial);
            lock.position.set(0, 1.2, 0.76);
            chest.add(lock);

            chest.position.set(x, y, z);
            chest.userData = {
                type: 'chest',
                opened: false,
                loot: {
                    gold: Math.floor(Math.random() * 50) + 10,
                    items: Math.random() > 0.5 ? 'potion' : 'food',
                    quantity: Math.floor(Math.random() * 3) + 1
                }
            };

            scene.add(chest);
            chests.push(chest);
        }

        function setupControls() {
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;

                if (e.key >= '1' && e.key <= '5') {
                    selectInventorySlot(parseInt(e.key) - 1);
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            document.addEventListener('click', () => {
                if (!isPointerLocked) {
                    const canvas = document.getElementById('gameCanvas');
                    try {
                        if (canvas.requestPointerLock) {
                            canvas.requestPointerLock();
                        } else if (canvas.mozRequestPointerLock) {
                            canvas.mozRequestPointerLock();
                        } else if (canvas.webkitRequestPointerLock) {
                            canvas.webkitRequestPointerLock();
                        }
                    } catch (e) {
                        console.log('Pointer lock non disponible, utilisez les touches fl√©ch√©es pour la cam√©ra');
                    }
                } else {
                    performAction();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = !!document.pointerLockElement;
            });

            document.addEventListener('mousemove', (e) => {
                if (isPointerLocked && e.movementX !== undefined) {
                    mouseX -= e.movementX * 0.002;
                    mouseY -= e.movementY * 0.002;
                    mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            document.querySelectorAll('.inventory-slot').forEach((slot, index) => {
                slot.addEventListener('click', () => selectInventorySlot(index));
            });
        }

        function setupTouchControls() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            if (isMobile) {
                document.getElementById('touchControls').style.display = 'block';
            }

            // Joystick gauche (d√©placement)
            const joystickLeft = document.getElementById('joystickLeft');
            const joystickKnobLeft = document.getElementById('joystickKnobLeft');
            
            joystickLeft.addEventListener('touchstart', handleJoystickStart.bind(null, 'left'));
            joystickLeft.addEventListener('touchmove', handleJoystickMove.bind(null, 'left', joystickLeft, joystickKnobLeft));
            joystickLeft.addEventListener('touchend', handleJoystickEnd.bind(null, 'left', joystickKnobLeft));

            // Joystick droite (cam√©ra)
            const joystickRight = document.getElementById('joystickRight');
            const joystickKnobRight = document.getElementById('joystickKnobRight');
            
            joystickRight.addEventListener('touchstart', handleJoystickStart.bind(null, 'right'));
            joystickRight.addEventListener('touchmove', handleJoystickMove.bind(null, 'right', joystickRight, joystickKnobRight));
            joystickRight.addEventListener('touchend', handleJoystickEnd.bind(null, 'right', joystickKnobRight));

            // Boutons d'action
            const btnJump = document.getElementById('btnJump');
            const btnAction = document.getElementById('btnAction');
            const btnInteract = document.getElementById('btnInteract');

            btnJump.addEventListener('touchstart', (e) => { e.preventDefault(); touchKeys['jump'] = true; });
            btnAction.addEventListener('touchstart', (e) => { e.preventDefault(); performAction(); });
            btnInteract.addEventListener('touchstart', (e) => { e.preventDefault(); checkInteractions(); });

            btnJump.addEventListener('touchend', () => { touchKeys['jump'] = false; });
        }

        function handleJoystickStart(side, e) {
            e.preventDefault();
            if (side === 'left') {
                joystickLeftActive = true;
            } else {
                joystickRightActive = true;
            }
        }

        function handleJoystickMove(side, joystick, knob, e) {
            e.preventDefault();
            if ((side === 'left' && !joystickLeftActive) || (side === 'right' && !joystickRightActive)) return;

            const touch = e.touches[0];
            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let deltaX = touch.clientX - centerX;
            let deltaY = touch.clientY - centerY;
            
            const maxDistance = rect.width / 2 - 25;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > maxDistance) {
                deltaX = (deltaX / distance) * maxDistance;
                deltaY = (deltaY / distance) * maxDistance;
            }
            
            knob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            
            const normalizedX = deltaX / maxDistance;
            const normalizedY = deltaY / maxDistance;
            
            if (side === 'left') {
                joystickLeftVector.x = normalizedX;
                joystickLeftVector.y = normalizedY;
            } else {
                joystickRightVector.x = normalizedX;
                joystickRightVector.y = normalizedY;
            }
        }

        function handleJoystickEnd(side, knob, e) {
            e.preventDefault();
            knob.style.transform = 'translate(-50%, -50%)';
            
            if (side === 'left') {
                joystickLeftActive = false;
                joystickLeftVector.x = 0;
                joystickLeftVector.y = 0;
            } else {
                joystickRightActive = false;
                joystickRightVector.x = 0;
                joystickRightVector.y = 0;
            }
        }

        function selectInventorySlot(index) {
            selectedSlot = index;
            document.querySelectorAll('.inventory-slot').forEach((slot, i) => {
                slot.classList.toggle('selected', i === index);
            });
        }

        function checkInteractions() {
            const playerPos = player.position.clone();

            items.forEach((item, index) => {
                if (item.userData.type === 'sword_item') {
                    const distance = playerPos.distanceTo(item.position);
                    if (distance < 3) {
                        playerStats.hasSword = true;
                        scene.remove(item);
                        items.splice(index, 1);

                        inventory[0] = { type: 'weapon', name: '√âp√©e', icon: '‚öîÔ∏è', damage: 10, quantity: 1 };

                        addSwordToPlayer();

                        showMessage("Vous avez trouv√© l'√©p√©e l√©gendaire !");
                        updateInventoryUI();
                    }
                }
            });

            items.forEach(item => {
                if (item.userData.type === 'puzzle_lever') {
                    const distance = playerPos.distanceTo(item.position);
                    if (distance < 3 && !item.userData.activated) {
                        activateLever(item);
                    }
                }
            });
        }

        function checkDoorProximity() {
            const playerPos = player.position.clone();

            buildings.forEach(building => {
                const distance = playerPos.distanceTo(building.position);

                // D√©tecter la proximit√© d'une porte (maison ou donjon)
                if (building.userData.hasInterior) {
                    if (building.userData.type === 'dungeon_door') {
                        // V√©rifier si c'est le premier donjon qui n√©cessite l'√©nigme
                        if (building.position.x === -100 && building.position.z === -100) {
                            if (!dungeonPuzzleSolved) {
                                if (distance < 8) {
                                    showMessage("Porte verrouill√©e ! Appuyez sur E pour r√©soudre l'√©nigme");
                                }
                                return;
                            }
                        }
                        // Autres donjons sont accessibles directement
                        if (distance < 8) {
                            teleportToInterior(building);
                        }
                    } else {
                        // Maisons normales - toutes accessibles
                        if (distance < 8) {
                            teleportToInterior(building);
                        }
                    }
                }
            });
        }

        function addSwordToPlayer() {
            const swordGeometry = new THREE.BoxGeometry(0.1, 2, 0.3);
            const swordMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
            const sword = new THREE.Mesh(swordGeometry, swordMaterial);
            sword.position.set(0.9, 1, 0);
            sword.rotation.z = -0.2;
            sword.castShadow = true;
            sword.name = 'playerSword';
            player.add(sword);
        }

        function teleportToInterior(building) {
            // √âviter la t√©l√©portation multiple
            if (indoorMode) return;

            const interior = building.userData.interior;

            // Cacher le monde ext√©rieur

            if (building.userData.type === 'dungeon_door') {
                if (!building.userData.interiorCreated) {
                    createDungeonInterior(interior.x, interior.y, interior.z);
                    building.userData.interiorCreated = true;
                }
                player.position.set(interior.x, interior.y + 2, interior.z + 5);
            } else if (building.userData.type === 'house' || building.userData.type === 'start_house') {
                if (!building.userData.interiorCreated) {
                    createHouseInterior(interior.x, interior.y, interior.z, building.userData.type === 'start_house');
                    building.userData.interiorCreated = true;
                }
                player.position.set(interior.x, interior.y + 2, interior.z);
            }

            indoorMode = true;
            currentBuilding = building;
            showMessage("Appuyez sur E pour sortir");
        }

        function createHouseInterior(x, y, z, isStartHouse) {
            // Sol int√©rieur
            const floorGeometry = new THREE.PlaneGeometry(10, 10);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(x, y, z);
            floor.receiveShadow = true;
            floor.userData = { type: 'interior', parentBuilding: currentBuilding };
            scene.add(floor);

            // Murs int√©rieurs
            const wallHeight = 5;
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xD2B48C });

            // Mur nord
            const wallNorth = new THREE.Mesh(new THREE.PlaneGeometry(10, wallHeight), wallMaterial);
            wallNorth.position.set(x, y + wallHeight/2, z - 5);
            wallNorth.receiveShadow = true;
            wallNorth.userData = { type: 'interior' };
            scene.add(wallNorth);

            // Mur sud
            const wallSouth = new THREE.Mesh(new THREE.PlaneGeometry(10, wallHeight), wallMaterial);
            wallSouth.position.set(x, y + wallHeight/2, z + 5);
            wallSouth.rotation.y = Math.PI;
            wallSouth.receiveShadow = true;
            wallSouth.userData = { type: 'interior' };
            scene.add(wallSouth);

            // Mur est
            const wallEast = new THREE.Mesh(new THREE.PlaneGeometry(10, wallHeight), wallMaterial);
            wallEast.position.set(x + 5, y + wallHeight/2, z);
            wallEast.rotation.y = -Math.PI / 2;
            wallEast.receiveShadow = true;
            wallEast.userData = { type: 'interior' };
            scene.add(wallEast);

            // Mur ouest
            const wallWest = new THREE.Mesh(new THREE.PlaneGeometry(10, wallHeight), wallMaterial);
            wallWest.position.set(x - 5, y + wallHeight/2, z);
            wallWest.rotation.y = Math.PI / 2;
            wallWest.receiveShadow = true;
            wallWest.userData = { type: 'interior' };
            scene.add(wallWest);

            // Plafond
            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), new THREE.MeshLambertMaterial({ color: 0x654321 }));
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(x, y + wallHeight, z);
            ceiling.userData = { type: 'interior' };
            scene.add(ceiling);

            // Lumi√®re int√©rieure
            const interiorLight = new THREE.PointLight(0xFFE4B5, 1, 15);
            interiorLight.position.set(x, y + 4, z);
            interiorLight.castShadow = true;
            interiorLight.userData = { type: 'interior' };
            scene.add(interiorLight);

            // Table
            const tableTop = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.2, 2),
                new THREE.MeshLambertMaterial({ color: 0x8B4513 })
            );
            tableTop.position.set(x, y + 1.5, z - 2);
            tableTop.castShadow = true;
            tableTop.userData = { type: 'interior' };
            scene.add(tableTop);

            // Pieds de table
            for (let i = -1; i <= 1; i += 2) {
                for (let j = -1; j <= 1; j += 2) {
                    const leg = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8),
                        new THREE.MeshLambertMaterial({ color: 0x654321 })
                    );
                    leg.position.set(x + i * 1.3, y + 0.75, z - 2 + j * 0.8);
                    leg.castShadow = true;
                    leg.userData = { type: 'interior' };
                    scene.add(leg);
                }
            }

            // Chaises
            for (let i = 0; i < 2; i++) {
                const chair = new THREE.Group();

                const seat = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.1, 0.8),
                    new THREE.MeshLambertMaterial({ color: 0x654321 })
                );
                seat.position.y = 0.8;
                chair.add(seat);

                const backrest = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 1, 0.1),
                    new THREE.MeshLambertMaterial({ color: 0x654321 })
                );
                backrest.position.set(0, 1.3, -0.35);
                chair.add(backrest);

                chair.position.set(x + (i === 0 ? -2 : 2), y, z - 2);
                chair.rotation.y = i === 0 ? Math.PI / 2 : -Math.PI / 2;
                chair.castShadow = true;
                chair.userData = { type: 'interior' };
                scene.add(chair);
            }

            // Lit
            const bedFrame = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 0.5, 4),
                new THREE.MeshLambertMaterial({ color: 0x8B4513 })
            );
            bedFrame.position.set(x - 3, y + 0.5, z + 2);
            bedFrame.castShadow = true;
            bedFrame.userData = { type: 'interior' };
            scene.add(bedFrame);

            const mattress = new THREE.Mesh(
                new THREE.BoxGeometry(2.3, 0.3, 3.8),
                new THREE.MeshLambertMaterial({ color: 0xFF6347 })
            );
            mattress.position.set(x - 3, y + 0.9, z + 2);
            mattress.castShadow = true;
            mattress.userData = { type: 'interior' };
            scene.add(mattress);

            // Coffre
            const chestInterior = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 1, 1),
                new THREE.MeshLambertMaterial({ color: 0x654321 })
            );
            chestInterior.position.set(x + 3.5, y + 0.5, z + 3);
            chestInterior.castShadow = true;
            chestInterior.userData = { type: 'interior' };
            scene.add(chestInterior);

            // Pots d√©coratifs
            for (let i = 0; i < 3; i++) {
                const pot = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.4, 0.8, 8),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                pot.position.set(
                    x + (i - 1) * 2,
                    y + 0.4,
                    z - 4.5
                );
                pot.castShadow = true;
                pot.userData = { type: 'interior' };
                scene.add(pot);
            }

            // Tapis
            const rug = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 3),
                new THREE.MeshLambertMaterial({ color: 0x8B0000 })
            );
            rug.rotation.x = -Math.PI / 2;
            rug.position.set(x, y + 0.01, z);
            rug.userData = { type: 'interior' };
            scene.add(rug);
        }

        function activateLever(lever) {
            lever.userData.activated = true;
            lever.rotation.x = Math.PI / 4;
            lever.material.color.setHex(0x00FF00);

            const activatedLevers = items.filter(item => 
                item.userData.type === 'puzzle_lever' && item.userData.activated
            );

            if (activatedLevers.length === 4) {
                dungeonPuzzleSolved = true;
                showMessage("√ânigme r√©solue ! La porte du boss est ouverte !");
            } else {
                showMessage(`Levier ${lever.userData.order} activ√© !`);
            }
        }

        function exitBuilding() {
            // Nettoyer les objets d'int√©rieur
            const interiorObjects = scene.children.filter(obj => obj.userData.type === 'interior');
            interiorObjects.forEach(obj => scene.remove(obj));

            // Repositionner le joueur √† l'ext√©rieur
            player.position.set(
                currentBuilding.position.x,
                currentBuilding.position.y + 2,
                currentBuilding.position.z + 8
            );

            // Restaurer la vue ext√©rieure
            indoorMode = false;
            currentBuilding = null;
            showMessage("Vous √™tes sorti");
        }

        function performAction() {
            if (!playerStats.hasSword) {
                showMessage("Vous avez besoin d'une arme !");
                return;
            }

            // Animation d'attaque avec l'√©p√©e
            const sword = player.getObjectByName('playerSword');
            if (sword) {
                const originalRotation = sword.rotation.z;
                sword.rotation.z = -Math.PI / 2;
                setTimeout(() => {
                    sword.rotation.z = originalRotation;
                }, 200);
            }

            const playerPos = player.position.clone();

            enemies.forEach((enemy, index) => {
                const distance = playerPos.distanceTo(enemy.position);
                if (distance < 5) {
                    enemy.userData.health -= playerStats.damage;

                    createDamageEffect(enemy.position);

                    if (enemy.userData.health <= 0) {
                        defeatedEnemy(enemy, index);
                    }
                }
            });

            chests.forEach(chest => {
                const distance = playerPos.distanceTo(chest.position);
                if (distance < 4 && !chest.userData.opened) {
                    openChest(chest);
                }
            });

            npcs.forEach(npc => {
                const distance = playerPos.distanceTo(npc.position);
                if (distance < 5) {
                    showDialog(npc.userData.name, npc.userData.dialog[Math.floor(Math.random() * npc.userData.dialog.length)]);
                }
            });
        }

        function defeatedEnemy(enemy, index) {
            playerStats.experience += enemy.userData.experience;
            playerStats.gold += enemy.userData.gold;

            if (playerStats.experience >= playerStats.level * 100) {
                levelUp();
            }

            scene.remove(enemy);
            enemies.splice(index, 1);

            showMessage(`+${enemy.userData.experience} XP, +${enemy.userData.gold} Or`);

            updateUI();
        }

        function openChest(chest) {
            chest.userData.opened = true;

            const lid = chest.children[1];
            lid.rotation.x = -Math.PI / 4;

            const loot = chest.userData.loot;
            playerStats.gold += loot.gold;

            if (loot.items === 'potion') {
                inventory[2].quantity += loot.quantity;
            } else if (loot.items === 'food') {
                inventory[1].quantity += loot.quantity;
            }

            showMessage(`Coffre ouvert ! +${loot.gold} Or, +${loot.quantity} ${loot.items}`);
            updateUI();
        }

        function levelUp() {
            playerStats.level++;
            playerStats.maxHealth += 20;
            playerStats.health = playerStats.maxHealth;
            playerStats.damage += 5;
            playerStats.defense += 2;

            showMessage(`NIVEAU ${playerStats.level} !`);

            const levelUpEffect = new THREE.PointLight(0xFFD700, 5, 20);
            levelUpEffect.position.copy(player.position);
            scene.add(levelUpEffect);
            setTimeout(() => scene.remove(levelUpEffect), 1000);
        }

        function createDamageEffect(position) {
            const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
            const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });

            for (let i = 0; i < 5; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.2
                );
                scene.add(particle);
                particles.push(particle);

                setTimeout(() => {
                    scene.remove(particle);
                    particles = particles.filter(p => p !== particle);
                }, 1000);
            }
        }

        function showMessage(text) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.style.display = 'block';
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 2000);
        }

        function showDialog(speaker, text) {
            const dialogBox = document.getElementById('dialogBox');
            const dialogSpeaker = document.getElementById('dialogSpeaker');
            const dialogText = document.getElementById('dialogText');

            dialogSpeaker.textContent = speaker;
            dialogText.textContent = text;
            dialogBox.style.display = 'block';

            setTimeout(() => {
                dialogBox.style.display = 'none';
            }, 5000);
        }

        function updateUI() {
            document.getElementById('healthFill').style.width = (playerStats.health / playerStats.maxHealth * 100) + '%';
            document.getElementById('hungerFill').style.width = (playerStats.hunger / playerStats.maxHunger * 100) + '%';
            document.getElementById('experienceFill').style.width = ((playerStats.experience % 100) / 100 * 100) + '%';

            document.getElementById('level').textContent = playerStats.level;
            document.getElementById('gold').textContent = playerStats.gold;
            document.getElementById('position').textContent = `${Math.round(player.position.x)}, ${Math.round(player.position.z)}`;

            const hour = Math.floor(gameTime / 1000) % 24;
            document.getElementById('gameTime').textContent = hour < 6 || hour > 20 ? 'Nuit' : 'Jour';

            updateInventoryUI();
        }

        function updateInventoryUI() {
            const slots = document.querySelectorAll('.inventory-slot');
            inventory.forEach((item, index) => {
                if (slots[index]) {
                    slots[index].innerHTML = item.icon;
                    if (item.quantity > 1) {
                        const count = document.createElement('span');
                        count.className = 'item-count';
                        count.textContent = item.quantity;
                        slots[index].appendChild(count);
                    }
                }
            });
        }

        function updateMinimap() {
            const minimapCanvas = document.getElementById('minimapCanvas');
            const ctx = minimapCanvas.getContext('2d');
            const size = 150;
            minimapCanvas.width = size;
            minimapCanvas.height = size;

            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, size, size);

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= 10; i++) {
                ctx.beginPath();
                ctx.moveTo(i * size / 10, 0);
                ctx.lineTo(i * size / 10, size);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * size / 10);
                ctx.lineTo(size, i * size / 10);
                ctx.stroke();
            }

            const playerX = size / 2 + player.position.x * 0.5;
            const playerZ = size / 2 + player.position.z * 0.5;

            ctx.fillStyle = '#00FF00';
            ctx.beginPath();
            ctx.arc(playerX, playerZ, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FF0000';
            enemies.forEach(enemy => {
                const enemyX = size / 2 + enemy.position.x * 0.5;
                const enemyZ = size / 2 + enemy.position.z * 0.5;
                if (enemyX >= 0 && enemyX <= size && enemyZ >= 0 && enemyZ <= size) {
                    ctx.beginPath();
                    ctx.arc(enemyX, enemyZ, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.fillStyle = '#FFD700';
            chests.forEach(chest => {
                if (!chest.userData.opened) {
                    const chestX = size / 2 + chest.position.x * 0.5;
                    const chestZ = size / 2 + chest.position.z * 0.5;
                    if (chestX >= 0 && chestX <= size && chestZ >= 0 && chestZ <= size) {
                        ctx.fillRect(chestX - 2, chestZ - 2, 4, 4);
                    }
                }
            });
        }

        function handleMovement() {
            const moveSpeed = playerStats.speed;
            const direction = new THREE.Vector3();

            // Support clavier
            if (keys['z'] || keys['w']) direction.z -= 1;
            if (keys['s']) direction.z += 1;
            if (keys['q'] || keys['a']) direction.x -= 1;
            if (keys['d']) direction.x += 1;

            // Support joystick gauche pour d√©placement
            if (joystickLeftActive) {
                direction.x += joystickLeftVector.x;
                direction.z += joystickLeftVector.y;
            }

            // D√©tection du mouvement pour les animations
            isPlayerMoving = direction.length() > 0;

            // Contr√¥les cam√©ra clavier
            if (keys['arrowleft']) {
                mouseX += 0.05;
            }
            if (keys['arrowright']) {
                mouseX -= 0.05;
            }
            if (keys['arrowup']) {
                mouseY = Math.min(Math.PI/2, mouseY + 0.05);
            }
            if (keys['arrowdown']) {
                mouseY = Math.max(-Math.PI/2, mouseY - 0.05);
            }

            // Support joystick droite pour cam√©ra
            if (joystickRightActive) {
                mouseX -= joystickRightVector.x * 0.05;
                mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY - joystickRightVector.y * 0.05));
            }

            direction.normalize();

            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), mouseX);

            velocity.x = direction.x * moveSpeed;
            velocity.z = direction.z * moveSpeed;

            if ((keys[' '] || touchKeys['jump']) && canJump) {
                velocity.y = playerStats.jumpPower;
                canJump = false;
                touchKeys['jump'] = false;
            }

            velocity.y -= 0.01;

            player.position.add(velocity);

            if (player.position.y <= 2) {
                player.position.y = 2;
                velocity.y = 0;
                canJump = true;
            }

            player.position.x = Math.max(-490, Math.min(490, player.position.x));
            player.position.z = Math.max(-490, Math.min(490, player.position.z));

            player.rotation.y = mouseX + Math.PI;

            // Animations am√©lior√©es du personnage
            const leftArm = player.children.find(c => c.position.x < 0 && c.geometry instanceof THREE.BoxGeometry && c.geometry.parameters.width === 0.3);
            const rightArm = player.children.find(c => c.position.x > 0 && c.geometry instanceof THREE.BoxGeometry && c.geometry.parameters.width === 0.3);
            const leftLeg = player.children.find(c => c.position.x < 0 && c.geometry instanceof THREE.BoxGeometry && c.geometry.parameters.width === 0.4);
            const rightLeg = player.children.find(c => c.position.x > 0 && c.geometry instanceof THREE.BoxGeometry && c.geometry.parameters.width === 0.4);
            const body = player.children.find(c => c.geometry instanceof THREE.BoxGeometry && c.geometry.parameters.height === 1.5);
            const head = player.children.find(c => c.geometry instanceof THREE.SphereGeometry && c.position.y > 2);

            if (isPlayerMoving) {
                // Animation de marche fluide
                walkAnimationTime += 0.15;
                
                if (leftArm) {
                    leftArm.rotation.x = Math.sin(walkAnimationTime) * 0.6;
                    leftArm.rotation.z = Math.sin(walkAnimationTime * 0.5) * 0.1;
                }
                if (rightArm) {
                    rightArm.rotation.x = Math.sin(walkAnimationTime + Math.PI) * 0.6;
                    rightArm.rotation.z = -Math.sin(walkAnimationTime * 0.5) * 0.1;
                }
                if (leftLeg) {
                    leftLeg.rotation.x = Math.sin(walkAnimationTime + Math.PI) * 0.4;
                }
                if (rightLeg) {
                    rightLeg.rotation.x = Math.sin(walkAnimationTime) * 0.4;
                }
                
                // L√©ger balancement du corps
                if (body) {
                    body.rotation.z = Math.sin(walkAnimationTime * 0.5) * 0.05;
                }
                
                // Balancement de la t√™te
                if (head) {
                    head.rotation.z = Math.sin(walkAnimationTime * 0.5) * 0.08;
                }
            } else {
                // Animation idle subtile
                const idleTime = Date.now() * 0.001;
                
                if (leftArm) {
                    leftArm.rotation.x = Math.sin(idleTime) * 0.05;
                    leftArm.rotation.z = 0;
                }
                if (rightArm) {
                    rightArm.rotation.x = Math.sin(idleTime + Math.PI) * 0.05;
                    rightArm.rotation.z = 0;
                }
                if (leftLeg) leftLeg.rotation.x = 0;
                if (rightLeg) rightLeg.rotation.x = 0;
                
                if (body) {
                    body.rotation.z = Math.sin(idleTime * 0.5) * 0.02;
                }
                
                if (head) {
                    head.rotation.z = Math.sin(idleTime * 0.3) * 0.03;
                    head.rotation.x = Math.sin(idleTime * 0.2) * 0.02;
                }
            }

            // Animation de l'√©p√©e
            const sword = player.getObjectByName('playerSword');
            if (sword) {
                if (isPlayerMoving) {
                    sword.rotation.y = Math.sin(walkAnimationTime * 0.8) * 0.3;
                    sword.rotation.z = -0.2 + Math.sin(walkAnimationTime * 0.5) * 0.1;
                } else {
                    sword.rotation.y = Math.sin(Date.now() * 0.002) * 0.15;
                    sword.rotation.z = -0.2;
                }
            }

            // V√©rifier la proximit√© des portes pour t√©l√©portation automatique
            if (!indoorMode) {
                checkDoorProximity();
            }

            if (keys['e']) {
                if (indoorMode && currentBuilding) {
                    exitBuilding();
                } else {
                    checkInteractions();
                }
                keys['e'] = false;
            }
        }

        function updateCamera() {
            let cameraDistance = indoorMode ? 6 : 10;
            let cameraHeight = indoorMode ? 3 : 5;

            const targetX = player.position.x + Math.sin(mouseX) * cameraDistance;
            const targetY = player.position.y + cameraHeight - mouseY * (indoorMode ? 3 : 5);
            const targetZ = player.position.z + Math.cos(mouseX) * cameraDistance;

            // Interpolation pour un mouvement fluide
            camera.position.x += (targetX - camera.position.x) * 0.1;
            camera.position.y += (targetY - camera.position.y) * 0.1;
            camera.position.z += (targetZ - camera.position.z) * 0.1;

            const lookAtTarget = new THREE.Vector3(
                player.position.x,
                player.position.y + 1,
                player.position.z
            );
            camera.lookAt(lookAtTarget);
        }

        function updateEnemies() {
            enemies.forEach(enemy => {
                const distance = player.position.distanceTo(enemy.position);

                if (distance < 20) {
                    const direction = new THREE.Vector3();
                    direction.subVectors(player.position, enemy.position);
                    direction.y = 0;
                    direction.normalize();

                    enemy.position.add(direction.multiplyScalar(enemy.userData.speed));
                    enemy.lookAt(player.position);

                    // Animation de saut en approchant
                    enemy.position.y = 1 + Math.abs(Math.sin(Date.now() * 0.01)) * 0.5;

                    if (distance < 2) {
                        playerStats.health -= enemy.userData.damage * 0.01;
                        playerStats.health = Math.max(0, playerStats.health);

                        if (playerStats.health <= 0) {
                            gameOver();
                        }
                    }
                } else {
                    enemy.position.x += (Math.random() - 0.5) * 0.05;
                    enemy.position.z += (Math.random() - 0.5) * 0.05;

                    // Animation de rebondissement quand inactif
                    enemy.position.y = 1 + Math.sin(Date.now() * 0.003 + enemy.position.x) * 0.2;
                }
            });
        }

        function updateAnimals() {
            animals.forEach(animal => {
                animal.userData.changeDirectionTimer++;

                if (animal.userData.changeDirectionTimer > 100) {
                    animal.userData.direction = new THREE.Vector3(
                        Math.random() - 0.5,
                        0,
                        Math.random() - 0.5
                    ).normalize();
                    animal.userData.changeDirectionTimer = 0;
                }

                animal.position.add(animal.userData.direction.clone().multiplyScalar(animal.userData.speed));

                animal.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.3;

                if (animal.userData.direction.length() > 0) {
                    animal.lookAt(animal.position.clone().add(animal.userData.direction));
                }

                animal.position.x = Math.max(-490, Math.min(490, animal.position.x));
                animal.position.z = Math.max(-490, Math.min(490, animal.position.z));
            });
        }

        function updateHunger() {
            playerStats.hunger -= 0.01;
            playerStats.hunger = Math.max(0, playerStats.hunger);

            if (playerStats.hunger <= 0) {
                playerStats.health -= 0.1;
                playerStats.health = Math.max(0, playerStats.health);
            }

            if (keys['e'] && selectedSlot === 1 && inventory[1].quantity > 0) {
                playerStats.hunger = Math.min(playerStats.maxHunger, playerStats.hunger + 30);
                playerStats.health = Math.min(playerStats.maxHealth, playerStats.health + 20);
                inventory[1].quantity--;
                keys['e'] = false;
                showMessage("Vous avez mang√© de la viande !");
            }

            if (keys['e'] && selectedSlot === 2 && inventory[2].quantity > 0) {
                playerStats.health = Math.min(playerStats.maxHealth, playerStats.health + 50);
                inventory[2].quantity--;
                keys['e'] = false;
                showMessage("Vous avez bu une potion de soin !");
            }
        }

        function updateDayNight() {
            gameTime += 10;
            const hour = Math.floor(gameTime / 1000) % 24;

            const sky = scene.children.find(child => child.geometry instanceof THREE.SphereGeometry);
            const directionalLight = scene.children.find(child => child instanceof THREE.DirectionalLight);

            if (sky && directionalLight) {
                if (hour >= 6 && hour <= 20) {
                    sky.material.color.setHex(0x87CEEB);
                    directionalLight.intensity = 1;
                } else {
                    sky.material.color.setHex(0x0a0a2e);
                    directionalLight.intensity = 0.3;
                }
            }
        }

        function updateParticles() {
            particles.forEach(particle => {
                if (particle.velocity) {
                    particle.position.add(particle.velocity);
                    particle.velocity.y -= 0.01;
                }
            });
        }

        function gameOver() {
            showMessage("GAME OVER - Rechargez la page pour recommencer");
            keys = {};
            touchKeys = {};
        }

        function animate() {
            requestAnimationFrame(animate);

            if (player) {
                handleMovement();
                updateCamera();
                updateEnemies();
                updateAnimals();
                updateHunger();
                updateDayNight();
                updateParticles();
                updateUI();
                updateMinimap();
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
